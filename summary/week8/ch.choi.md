# **18 선형 자료 구조**


## **18.1 도입**

배열과 같이 일렬로 늘어선 자료들을 저정하기 위한 자료 구조인 동적 배열과 연결 리스트에 대해 다룸.

두 구조는 배열과 비슷, 배열에서 비효율적이거나 할 수 없는 작업들을 효율적으로 할 수 있도록 도와줌.


## **18.2 동적 배열**

**배열의 문제**
- 선언 시 배열의 크기 지정
- 정한 크기 그 이상의 자료를 저장 할 수 없음 

배열의 문제를 해결하기 위해 고안된 것이 동적 배열.  
동적 배열은 자료의 개수가 변함에 따라 크기가 변경 됨.  
동적 배열은 일반 배열처럼 언어 차원에서 지원되는 기능이 아니라 배열을 이용해 만들어 낸 별도의 자료 구조

내부적으로 배열을 이용하기 때문에 동적 배열은 배열이 갖는 다음과 같은 특성을 그래도 이어받음.

**배열의 특성**
- 원소들은 메모리의 연속된 위치에 저장됨
- 주어진 위치의 원소를 반호나하거나 변경하는 동작을 O(1)에 수행

**동적 배열의 추가적 특성**

- 배열의 크기를 변경하는 resize() 연산 가능
- 크기를 1 늘리는 append() 연산을 지원

동적 배열의 크기가 바뀌어야 할 때는 단순하게 새 배열을 동적으로 할당받은 뒤 기존 원소들을 복사하고, 새 배열을 참조하도록 바꿔치기함  
새 배열을 할당받고 기존 자료를 복사하는 데는 배열의 크기에 비례하는 시간이 걸림. resize()는 O(n)에 구현.

append()가 호출될 때마다 resize()를 호출하게 되면 수행시간이 선형 시간이 되어버림.  

메모리를 할당받을 때 배열의 크기가 커질 때를 대비해서 여유분의 메모리를 미리 할당받아 두는 것  
동정 배열의 내부에서는 배열의 크기가 커지는것에 대비해 여유분의 메모리를 확보 함  

![그림 18.1 동적배열](https://github.com/ohbokdong/AlgorithmStudy/blob/main/summary/week8/img/pic_18_1.PNG?raw=true)  
[그림 18.1 동적배열 참조 출처](https://noahlogs.tistory.com/29)

미리 할당해 둔 메모리가 꽉 찼을 때 더 큰 새배열을 동적으로 할당받고  
새 배열에 기존 배열의 내용을 모두 복사한 다름 배열에 대한 포인터를 바꿔치기 함 - P611 참조


### **동적 배열의 재할당 전략**

append()로 추가 시 재할당 과정을 거치게 되면 선형 시간이 걸리게 됨  
수행 시간이 달라지는 함수의 시간 복잡도 계산은 여러번 반복 후 수행 시간의 평균을 내면 됨  
각 재할당 과정에 선형 시간이 걸리더라도 아주 가끔 일어난 다면 전체 평균은 여전히 상수 시간일 수도 있음

분석 해보면 M을 늘리는 것으로 아무런 의미가 없음을 깨달을 수 있음. N번  append() 연산을 할 때 재할당의 수 K = O(N/M).  
M은 상수 임으로 N이 아주 커지면 결국 K = O(N)이라고 쓸 수 있음.

**배열의 용량을 한번에 M 씩 증가** - 1만 크기 배열을 만들시

1. m = 100 일때 50만번의 복사가 필요.
2. m = 1000 일때 4만5천의 복사가 필요. 하지만 용량 낭비가 심함
3. m = 크기의 2배로 할당 시 16383번의 복사가 필요 

배열의 용량이 꽉 찼을 때 이것을 어떻게 증가시키느냐 반대로 배열의 크기가 용량에 비해 많이 즐어들었을 때 어떻게 줄이느냐 등의 전략은 동적 배열의 효율성에 큰 영향을 미침

**표준 라이브러리의 동적 배열 구현**

대부분의 언어들은 동적 배열을 표준 라이브러리에서 제공  
append()연산을 여러 번 수행할 때 배열의 최종 크기가 얼마인지 미리 짐작할 수 있다면 동적 배열의 용량을 미리 늘려 둠으로써 재할당 비용을 없앨수 있음.  
가끔 일반배열을 동적 배열로 교체하면 느려지는 경우가 있음. 이와 같은 최적화를 적용하면 문제가 해결되는 경우가 많음.

## **18.3 연결 리스트**

원소들의 순서를 유지하고 원소를 삽입, 삭제하는 것은 시간이 오래걸리는 작업임. 평균적인 경우 이 작업들은 원소의 개수에 선형 비례하는 시간이 걸림

문제를 해결하기 위해 고안된 자료구조가 연결 리스트  
삽입과 삭제를 상수 시간에 할 수 있게 해줌. 연결 리스트는 배열과 아주 다른 형태
배열은 메모리의 연속된 위치에 각 원소들이 저장 되어 있지만  
연결 리스트는 원소들이 메모리 여기저기 흩어져 있고 각 원소들이 이전과 다음 원소를 가르키는 포인터를 가지고 있는 방식 으로 구현됨 - p616 그림 18.3 참조

원소와 포인터의 집합을 노드라고 함 

연결리스트는 첫 번째 노드와 마지막 노드에 대한 포인터를 가지고 있음

### **연결 리스트 다루기**

연결 리스트에서는 메모리 여기저기에 오느들이 흩어져 있기 때문에 특정 위치의 값을 찾기 쉽지 않음.  
결과적으로 i번째 노드를 찾는데 드는 시간은 리스트의 길이에 선형 비례함  
반면 다른 노드들의 순서를 유지하면서 새 노드를 삽입하거나 기존 노드를 삭제하는 작업은 아주 간단

**표준 라이브러리의 연결 리스트 구현**
c++ STL의 LIST, 자바와 c#의 LikendList가 이와 같은 자료 구조

### **연결 리스트 응용 연산들**

**잘라 붙이기 연산**
포인터만을 변경해 원소의 삭제와 삽입을 상수 시간에 할 수 있덨던걸 이용 하여 다른 리스트의 일부를 끼워 넣는 연산을 할 수 있음  
연산 잘라 붙이기 splicing 이라고 부름  
잘라 붙이기를 하게될 경우 연결 리스트의 크기를 O(1)로 알 수 없음. 잘라 붙이기 할때 몇 개의 원소가 추가 되는지 알 방법이 없기 때문  
장단점으로 인해 언어 별로 지원 여부가 틀림 

**삭제했던 원소 돌려놓기**

한 번 삭제했던 원소를 제자리에 쉽게 돌려 놓을 수 있다는 것.  
이전/이후 노드의 포인터를 돌려 놓았을 뿐 정보가 변하지는 않음.
노드의 포인터들은 원래 자기가 들어가 있던 위치를 알고 있기 때문에 원래 리스트에 쉽게 다시 삽입 가능  
하지만 삭제한 순서의 반대로 복구가 이루어질 때만 사용 할 수 있음

undo 연산 지원하는데 유용하게 쓸 수 있음

## **18.4 동적 배열과 연결 리스트의 비교**

동적 배열과 연결 리스트의 가장 큰 차이점은 삽입과 삭제 그리고 임의의 원소에 접근하는 데 드는 시간

원소들이 메모리에 연속 배치되어있다는 점이 CPU 캐시의 효율도 더 높여 주기 때문












