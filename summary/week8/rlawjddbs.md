# 9. 선형 자료 구조
## 9.1. 배열
- 일렬로 늘어선 같은 종류의 자료 여러 개를 저장하기 위한 가장 기초적인 자료구조
- 원소들은 **메모리의 연속된 위치**에 저장됨
- 주어진 위치의 원소를 반환하거나 변경하는 동작을 *O(1)*에 할 수 있음
- 처음 배열을 선언할 때 **배열의 크기를 지정**해야 함
    - 지정한 크기 이상의 자료를 집어넣을 수 없음
   
   
## 9.2. 동적 배열
### 동적 배열 특징
- 자료 개수가 변함에 따라 크기 변경
- 일반 배열을 이용해 만들어 낸 별도의 자료 구조
- 배열의 크기를 변경하는 `resize()` 연산 가능
    - 수행 시 배열 크기 `N`에 비례하는 시간 소요
- 주어진 원소를 배열의 맨 끝에 추가함으로써 크기를 1 늘리는 `append()` 연산 지원
    - 수행 시 상수 시간 소요
- 이와 같은 연산들을 구현하기 위해 동적 배열은 `동적으로 할당받은 배열`을 사용
    - dynamically allocated: new 등의 연산으로 할당받은 고정길이 배열을 이르는 말로, 동적으로 할당받은 배열과 동적 배열은 서로 별개의 개념
    - 동적 배열의 크기가 바뀌어야 할 때는 단순하게 새 배열을 동적으로 동적으로 할당받은 뒤 기존 원소들을 복사하고, 새 배열을 참조하도록 바꿔치기함
   
> #### 동적 배열 클래스 내부
```C++
int size; // 배열의 크기
ElementType* array; // 실제 배열을 가리키는 포인터
```
   
- 새 배열을 할당받고 기존 자료를 복사하는 데는 배열의 크기에 비례하는 시간이 걸리므로, 이와 같은 방법을 이용하면 `resize()` 연산을 ***O(N)***에 구현
- 문제는 `append()` 연산을 어떻게 상수 시간에 구현하느냐임
    - append()가 호출될 때마다 resize()를 호출하면 append()의 수행 시간도 선형 시간이 되어버림
    - 메모리를 할당받을 때 배열의 크기가 커질 때를 대비해서 여유분의 메모리를 미리 할당받아 두고, 배열이 이미 할당한 메모리에 꽉 찼을 때 더 큰 메모리를 할당받아 배열의 원소를 그 쪽으로 전부 옮기면 됨

![dinamically_array](https://github.com/ohbokdong/AlgorithmStudy/blob/main/summary/week8/images/dinamically_array.png)   
- (a)는 정수 8개 분의 메모리를 할당받았지만 배열의 크기는 6인 동적 배열의 메모리를 나타냄
- 여기서 **이미 할당받은 메모리의 크기**를 배열의 용량(`capacity`), **실제 원소의 수**를 배열의 크기(`size`)라 함
- (a)에서 음영으로 표현된 부분은 용량에는 포함되지만 크기에는 포함되지 않는 부분임
- 따라서 동적 배열은 현재 배열의 크기와 배열이 현재 저장된 메모리 내의 위치 외에도 용량을 함께 저장해야 함.

### append() 연산의 구현
```C++
// append(newValue)의 일부
array[size++] = newValue;
```
- 위 과정은 상수 시간에 구현할 수 있음
- (b)처럼 미리 할당해 둔 메모리가 꽉 찼을 때 `append()` 연산을 하기 위해서는 더 큰 새 배열을 동적으로 할당받고 새 배열에 기존 배열의 내용을 모두 복사한 다음 배열에 대한 포인터를 바꿔치기 해야 함
- 이러한 과정을 `재할당`이라고 함

```C++
// 배열 용량이 꽉 찼으면 재할당 받음
if(size == capacity) {
    // 용량을 M만큼 늘린 새 배열을 할당받음
    int newCapacity = capacity + M;
    int* newArray = new int[newCapacity];
    // 기존의 자료를 복사
    for(int i = 0; i < size; ++i)
        newArray[i] = array[i];
    // 기존 배열을 삭제하고, 새 배열로 바꿔치기함
    if(array) delete [] array;
    array = newArray;
    capacity = newCapacity;
}
// 배열의 끝에 원소를 삽입함
array[size++] = newValue;
```
- 위 코드는 배열이 꽉 찼을 때 미리 정해놓은 M이라는 크기만큼 배열의 용량을 늘려 주며, 위 조건문을 거치고 나면 항상 원소를 삽입할 남은 공간이 있다는 것을 보장할 수 있음
- 이 재할당 과정에 드는 시간은 ***O(N+M)*** 이며 `append()`를 수행하는데 선형 시간이 걸리는 것은 아주 가끔 일어나는 재할당 과정 때 뿐임

### 동적 배열의 재할당 전략
- 자세히 분석해 보면 동적 배열의 재할당에 M을 늘리는 것은 아무런 의미가 없음을 깨달을 수 있음
- 텅 빈 배열로 시작해서 N번 append() 연산을 할 때 재할당의 수는 ![재할당의 수](https://github.com/ohbokdong/AlgorithmStudy/blob/main/summary/week8/images/CodeCogsEqn1.gif)임
- 이 때 재할당마다 복사하는 원소의 수는 M개, 2M개, …, K•M개로 증가하므로, 전체 복사하는 원소의 수는 다음과 같음   
   
![전체 복사하는 원소의 수](https://github.com/ohbokdong/AlgorithmStudy/blob/main/summary/week8/images/CodeCogsEqn.gif)   
- N번의 append() 연산을 하는 데 드는 총 시간이 O(N<sup>2</sup>)이라면 한 번의 append() 연산에 드는 시간은 평균적으로 ![append 연산에 드는 시간](https://github.com/ohbokdong/AlgorithmStudy/blob/main/summary/week8/images/CodeCogsEqn2.gif)이 됨
- 따라서 이런 재할당 전략으로는 상수 시간에 append()를 구현한다는 우리 목표를 달성할 수 없음
- 상수 시간에 append()를 구현하는 비결은 재할당을 할 때마다 **정해진 개수의 여유분을 확보하는 것이 아니라**, **현재 가진 원소의 개수에 비례해서 여유분을 확보하는 것**
    - 예를 들어 배열 용량이 부족할 때마다 용량을 두 배로 늘리는 방법을 생각해볼 수 있음
    - 처음에 배열 용량 1에서 시작해서, 꽉차면 2로 늘리고, 그 후엔 다시 4로 늘린다고 하면 1만 번의 append() 연산시에 일어나는 재할당 시점과 복사의 수는 다음과 같음

<table>
    <tbody>
        <tr><th>재할당 시점</th><td>1</td>
            <td>2</td>
            <td>4</td>
            <td>8</td>
            <td>16</td>
            <td>32</td>
            <td>…</td>
            <td>2048</td>
            <td>4096</td>
            <td>8192</td></tr>
        <tr><th>새 배열의 크기</th><td>2</td>
            <td>4</td>
            <td>8</td>
            <td>16</td>
            <td>32</td>
            <td>64</td>
            <td>…</td>
            <td>4096</td>
            <td>8192</td>
            <td>8192</td></tr>
    </tbody>
</table>

- 이때 일어나는 복사의 총 수는 1+2+4+…+8192=16383
- 이와 같은 전략을 택하면 항상 복사의 수가 배열의 크기에 선형으로 비례함을 알 수 있음
- i(i≥0)번 재할당 시에 복사하는 원소의 수는 2<sup>i</sup>