# 9. 선형 자료 구조
## 9.1. 배열
- 일렬로 늘어선 같은 종류의 자료 여러 개를 저장하기 위한 가장 기초적인 자료구조
- 원소들은 **메모리의 연속된 위치**에 저장됨
- 주어진 위치의 원소를 반환하거나 변경하는 동작을 *O(1)*에 할 수 있음
- 처음 배열을 선언할 때 **배열의 크기를 지정**해야 함
    - 지정한 크기 이상의 자료를 집어넣을 수 없음
   
   
## 9.2. 동적 배열
### 동적 배열 특징
- 자료 개수가 변함에 따라 크기 변경
- 일반 배열을 이용해 만들어 낸 별도의 자료 구조
- 배열의 크기를 변경하는 `resize()` 연산 가능
    - 수행 시 배열 크기 `N`에 비례하는 시간 소요
- 주어진 원소를 배열의 맨 끝에 추가함으로써 크기를 1 늘리는 `append()` 연산 지원
    - 수행 시 상수 시간 소요
- 이와 같은 연산들을 구현하기 위해 동적 배열은 `동적으로 할당받은 배열`을 사용
    - dynamically allocated: new 등의 연산으로 할당받은 고정길이 배열을 이르는 말로, 동적으로 할당받은 배열과 동적 배열은 서로 별개의 개념
    - 동적 배열의 크기가 바뀌어야 할 때는 단순하게 새 배열을 동적으로 동적으로 할당받은 뒤 기존 원소들을 복사하고, 새 배열을 참조하도록 바꿔치기함
   
> #### 동적 배열 클래스 내부
```C++
int size; // 배열의 크기
ElementType* array; // 실제 배열을 가리키는 포인터
```
   
- 새 배열을 할당받고 기존 자료를 복사하는 데는 배열의 크기에 비례하는 시간이 걸리므로, 이와 같은 방법을 이용하면 `resize()` 연산을 ***O(N)***에 구현
- 문제는 `append()` 연산을 어떻게 상수 시간에 구현하느냐임
    - append()가 호출될 때마다 resize()를 호출하면 append()의 수행 시간도 선형 시간이 되어버림
    - 메모리를 할당받을 때 배열의 크기가 커질 때를 대비해서 여유분의 메모리를 미리 할당받아 두고, 배열이 이미 할당한 메모리에 꽉 찼을 때 더 큰 메모리를 할당받아 배열의 원소를 그 쪽으로 전부 옮기면 됨

![dinamically_array](https://github.com/ohbokdong/AlgorithmStudy/blob/main/summary/week8/images/dinamically_array.png)   
- (a)는 정수 8개 분의 메모리를 할당받았지만 배열의 크기는 6인 동적 배열의 메모리를 나타냄
- 여기서 **이미 할당받은 메모리의 크기**를 배열의 용량(`capacity`), **실제 원소의 수**를 배열의 크기(`size`)라 함
- (a)에서 음영으로 표현된 부분은 용량에는 포함되지만 크기에는 포함되지 않는 부분임
- 따라서 동적 배열은 현재 배열의 크기와 배열이 현재 저장된 메모리 내의 위치 외에도 용량을 함께 저장해야 함.

### append() 연산의 구현
```C++
// append(newValue)의 일부
array[size++] = newValue;
```
- 위 과정은 상수 시간에 구현할 수 있음
- (b)처럼 미리 할당해 둔 메모리가 꽉 찼을 때 `append()` 연산을 하기 위해서는 더 큰 새 배열을 동적으로 할당받고 새 배열에 기존 배열의 내용을 모두 복사한 다음 배열에 대한 포인터를 바꿔치기 해야 함
- 이러한 과정을 `재할당`이라고 함

```C++
// 배열 용량이 꽉 찼으면 재할당 받음
if(size == capacity) {
    // 용량을 M만큼 늘린 새 배열을 할당받음
    int newCapacity = capacity + M;
    int* newArray = new int[newCapacity];
    // 기존의 자료를 복사
    for(int i = 0; i < size; ++i)
        newArray[i] = array[i];
    // 기존 배열을 삭제하고, 새 배열로 바꿔치기함
    if(array) delete [] array;
    array = newArray;
    capacity = newCapacity;
}
// 배열의 끝에 원소를 삽입함
array[size++] = newValue;
```
- 위 코드는 배열이 꽉 찼을 때 미리 정해놓은 M이라는 크기만큼 배열의 용량을 늘려 주며, 위 조건문을 거치고 나면 항상 원소를 삽입할 남은 공간이 있다는 것을 보장할 수 있음
- 이 재할당 과정에 드는 시간은 ***O(N+M)*** 이며 `append()`를 수행하는데 선형 시간이 걸리는 것은 아주 가끔 일어나는 재할당 과정 때 뿐임

### 동적 배열의 재할당 전략
- 자세히 분석해 보면 동적 배열의 재할당에 M을 늘리는 것은 아무런 의미가 없음을 깨달을 수 있음
- 텅 빈 배열로 시작해서 N번 append() 연산을 할 때 재할당의 수는 ![재할당의 수](https://github.com/ohbokdong/AlgorithmStudy/blob/main/summary/week8/images/CodeCogsEqn1.gif)
- 이 때 재할당마다 복사하는 원소의 수는 M개, 2M개, …, K•M개로 증가하므로, 전체 복사하는 원소의 수는 다음과 같음   
   
![전체 복사하는 원소의 수](https://github.com/ohbokdong/AlgorithmStudy/blob/main/summary/week8/images/CodeCogsEqn.gif)   
- N번의 append() 연산을 하는 데 드는 총 시간이 O(N<sup>2</sup>)이라면 한 번의 append() 연산에 드는 시간은 평균적으로 ![append 연산에 드는 시간](https://github.com/ohbokdong/AlgorithmStudy/blob/main/summary/week8/images/CodeCogsEqn2.gif)
- 따라서 이런 재할당 전략으로는 상수 시간에 append()를 구현한다는 우리 목표를 달성할 수 없음
- 상수 시간에 append()를 구현하는 비결은 재할당을 할 때마다 **정해진 개수의 여유분을 확보하는 것이 아니라**, **현재 가진 원소의 개수에 비례해서 여유분을 확보하는 것**
    - 예를 들어 배열 용량이 부족할 때마다 용량을 두 배로 늘리는 방법을 생각해볼 수 있음
    - 처음에 배열 용량 1에서 시작해서, 꽉차면 2로 늘리고, 그 후엔 다시 4로 늘린다고 하면 1만 번의 append() 연산시에 일어나는 재할당 시점과 복사의 수는 다음과 같음

<table>
    <tbody>
        <tr><th>재할당 시점</th><td>1</td>
            <td>2</td>
            <td>4</td>
            <td>8</td>
            <td>16</td>
            <td>32</td>
            <td>…</td>
            <td>2048</td>
            <td>4096</td>
            <td>8192</td></tr>
        <tr><th>새 배열의 크기</th><td>2</td>
            <td>4</td>
            <td>8</td>
            <td>16</td>
            <td>32</td>
            <td>64</td>
            <td>…</td>
            <td>4096</td>
            <td>8192</td>
            <td>16384</td></tr>
    </tbody>
</table>

- 이때 일어나는 복사의 총 수는 1+2+4+…+8192=16383
- 이와 같은 전략을 택하면 항상 복사의 수가 배열의 크기에 선형으로 비례함을 알 수 있음
- i(i≥0)번 재할당 시에 복사하는 원소의 수는 2<sup>i</sup>이며 각 재할당마다 일어난 복사들의 수를 아래처럼 그릴 수 있음   
   
![append() 연산으로 K번의 재할당이 일어났다면?](https://github.com/ohbokdong/AlgorithmStudy/blob/main/summary/week8/images/appendOperation.png)   
- 마지막 재할당에 필요한 복사의 수를 맨 아래에 두면, K-2번 재할당의 복사의 수는 그 절반이 됨
- K-3번 재할당은 그 절반이 되며, 이렇게 그림을 채워 나가면 처음부터 K-2번 재할당까지 복사하는 원소의 수의 합은 마지막 K-1번 재할당에서 복사하는 원소의 수와 거의 같다는 것을 알 수 있음
- 그런데 마지막 재할당에서 복사하는 원소의 수 2<sup>K-1</sup>이 ***O(N)***이기 때문에, 이것을 두 번 하더라도 전체 복사의 양은 ***O(N)***이 됨
- append() 연산을 N번 실행하는 총 수행 시간이 ***O(N)***이라면, 한 번의 append()에 드는 시간은 평균적으로 ***O(1)***이라고도 할 수 있음
   
## 9.3. 연결 리스트
- 배열 원소들의 순서를 유지하면서 임의의 위치에 원소를 삽입하거나, 임의의 위치에서 원소를 삭제하는 것은 시간이 오래 걸리는 작업임
    - 해당 위치 뒤에 있는 원소들을 하나씩 뒤칸 혹은 앞칸으로 옮겨야 하기 때문
    - 정확한 수행 시간은 삽입이나 삭제 위치에 따라 다르지만, 평균적인 경우 이 작업들에는 원소의 개수에 `선형 비례`하는 시간이 걸림
- 이와 같은 문제를 해결하기 위해 고안된 자료 구조가 `연결 리스트(linked list)`로, 특정 위치에서의 삽입과 삭제를 `상수 시간`에 할 수 있게 해 줌
- 연결리스트는 배열과 아주 다른 형태를 가지고 있음
    - 배열에서는 메모리의 연속된 위치에 각 원소들이 저장되어 있다면, 연결 리스트는 원소들이 메모리 여기 저기 흩어져 있고 각 원소들이 **이전과 다음 원소를 가리키는 포인터**를 가지고 있는 방식으로 구현됨
![배열과 연결 리스트의 차이](https://github.com/ohbokdong/AlgorithmStudy/blob/main/summary/week8/images/appendOperation.png)   
```C++
struct ListNode {
    int element; // 담고 있는 원소
    ListNode *prev, *next; // 이전 노드, 다음 노드의 포인터
}
```
- (b)에서 사각형으로 표현된 원소와 포인터의 집합들을 리스트의 `노드(node)`라고 부름
- 연결 리스트는 첫 번째 노드와 마지막 노드에 대한 포인터를 가지고 있는데, 이들을 각각 머리(head)와 꼬리(tail)라고 부름
- 대개 연결 리스트는 이와 같이 머리와 꼬리에 대한 포인터만을 가진 클래스로 구현 됨

### 연결 리스트 다루기
- 배열과는 달리 연결 리스트에서는 메모리 여기저기에 노드들이 흩어져 있기 때문에 특정 위치의 값을 찾기가 쉽지 않음
    - 연결 리스트에서 i번째 노드를 찾아내려면 리스트의 머리에서부터 시작해 하나씩 포인터를 따라가며 다음 노드를 찾을 수 밖에 없음
        - 결과적으로 i번째 노드를 찾는데 드는 시간은 리스트의 길이에 선형 비례
- 반면 다른 노드들의 순서를 유지하면서 새 노드를 삽입하거나 기존 노드를 삭제하는 작업은 아주 간단함
    - 다른 노드들은 그대로 두고, 삽입/삭제할 노드와 이전/이후 노드의 포인터만 바꾸면 됨

![연결리스트 포인터 변경](https://github.com/ohbokdong/AlgorithmStudy/blob/main/summary/week8/images/del_element_of_linkedList.png)   
- 점선은 이전의 포인터 정보, 실선은 바뀌어야 할 새 포인터 정보
- 이처럼 포인터만 변경하면 되기 때문에 연결 리스트에서의 삽입과 삭제는 각각 상수 시간에 이루어짐
- 이와 같이 연결 리스트는 배열과 매우 다른 특성을 갖고 있기 때문에 동적 배열과 서로 보완하는 관계로 자주 사용됨

### 연결 리스트 응용 연산들
#### 잘라 붙이기 연산
- 연결 리스트에서 노드들 간의 포인터만 변경해 원소의 삭제와 삽입을 상수 시간에 할 수 있었던 것을 응용하면 다른 리스트를 통째로 삽입하는 것 또한 상수 시간에 할 수 있음   
   
![연결리스트 잘라 붙이기 연산](https://github.com/ohbokdong/AlgorithmStudy/blob/main/summary/week8/images/splice_of_linkedList.png)   
- 위 그림의 (a)와 (b)는 리스트 lg의 일부를 리스트 lotte에 끼워넣는 연산이 어떻게 이루어지는지 보여줌. 결과적으로 원래는 lg에 속해 있던 노드들이 이제 lotte에 포함되어 있다는 걸 확인할 수 있음
- 이와 같은 연산을 `잘라 붙이기(splicing)`라고 부름
- 잘라 붙이기 연산을 쓰면 두 연결 리스트를 상수 시간에 하나로 합치거나 할 수 있어서 아주 유용하지만, 잘라 붙이기 연산을 구현하면 연결 리스트의 크기를 ***O(1)***에 알기가 불가능해짐
    - 연결 리스트에서는 크기를 알 수 있는 방법이 없어서 원소의 개수를 리스트 객체에서 유지하면서 새 원소를 삽입하거나 삭제할 때마다 갱신해 줘야 하는데, 잘라 붙이기 연산을 할 때는 몇 개의 원소가 추가되는지 알 방법이 없이 때문
    - 이와 같은 특성 때문에 잘라 붙이기 연산을 지원하는 연결 리스트 구현은 많지 않음
   
#### 삭제했던 원소 돌려놓기
- 양방향 연결 리스트의 잘 알려지지 않은 장점으로, 한 번 삭제했던 원소를 제자리에 쉽게 돌려 놓을 수 있다는 점이 있음
```C++
// 코드 18.1 연결 리스트에서 노드를 삭제하고 다시 추가하기

// node 이전/이후 노드의 포인터를 바꿔서 node를 리스트에서 삭제
void deleteNodeList(ListNode* node) {
    node -> prev -> next = node -> next;
    node -> next -> prev = node -> prev;
}
// node 이전/이후 노드의 포인터를 바꿔서 자기 자신을 다시 리스트에 삽입
void recoverNode(ListNode* node) {
    node -> prev -> next = node;
    node -> next -> prev = node;
}
```

- 위 코드는 연결 리스트에서 노드 x를 삭제하는 `deleteNode()`의 구현을 보여줌
- 이때 우리가 바꾼 것은 node의 이전/이후 노드의 포인터 뿐이며, node에 들어 있는 정보는 변하지 않았음
- node의 포인터들은 원래 자기가 들어가 있던 위치를 알고 있기 때문에, `recoverNode()`처럼 node에 대해서만 알고 있어도 원래 리스트에 쉽게 다시 삽입할 수 있음
- 물론 이 방법은 이전 노드나 이후 노드 또한 삭제된 상태에서 수행하면 리스트를 망가뜨리기 때문에, 항상 삭제한 순서의 반대로 복구가 이루어질 때만 사용할 수 있음
   
- 위 연산은 프로그램에서 `되돌리기(undo)` 연산을 지원하는 데 유용하게 쓸 수 있음

## 9.4. 동적 배열과 연결 리스트의 비교
- 동적 배열과 연결 리스트의 가장 큰 차이점은 **삽입과 삭제 그리고 임의의 원소에 접근하는 데 드는 시간**
- 삽입과 삭제를 할 일이 없거나, 배열의 끝에서만 하면 될 경우에는 `동적 배열`이 거의 항상 더 좋은 선택
    - 임의의 원소에 빠르게 접근할 수 있을 뿐더러, 원소들이 메모리에 연속해 배치되어 있다는 점이 CPU 캐시의 효율도 더 높여 주기 때문
    - 만약 임의의 원소를 접근하는 것이 아니라 모든 원소들을 순회하며 삽입과 삭제를 한다면 `연결 리스트`가 좋은 선택

|작업|동적 배열|연결 리스트|
|---|:---:|---|
|이전 원소/다음 원소 찾기|O(1)|O(1)
|맨 뒤에 원소 추가/삭제하기|O(1)|O(1)
|맨 뒤 이외의 위치에 원소 추가/삭제하기|O(n)|O(1)
|임의의 위치의 원소 찾기|O(1)|O(n)
|크기 구하기|O(1)|O(n) 혹은 구현에 따라 O(1)

## 9.5. 문제: 조세푸스 문제(문제 ID: JOSEPHUS, 난이도: 하)
- 역사학자 조세푸스가 로마와의 전쟁에서 패해 출구없는 동굴에 N명의 동료 병사와 포위당한 상태
- 항복하느니 차라리 자살하자고 결의함
- 포위당한 N명의 사람들이 모두 원형으로 둘러선 뒤 한 사람이 자살하면, 다음에는 그 사람으로부터 K번째 떨어진 사람이 자살하는 방식으로 결정
- 이때 마지막 살아남는 두 사람의 번호를 오름차순으로 출력하는 문제
### 입력
```
N = 총 인원 수 (3≤N)
K = 이전에 죽은 사람으로부터 시계방향으로 K번째에 위치한 사람 (K≤1000)
```
### 출력
- 마지막 살아남는 두 사람의 번호를 오름차순으로 출력
- 첫 번째로 자살하는 병사의 번호가 1이며, 다른 사람들의 번호는 첫 번째 병사에서부터 시계 방향으로 정해짐
### 예제 입력
```
6 3
40 3
```
### 예제 출력
```
3 5
11 26
```
## 9.6. 풀이
- 연결 리스트로 풀 수 있는 전형적인 문제
- 원형으로 연결된 연결 리스트 위에서 이번에 죽을 사람을 가리키는 포인터 `kill`을 유지하면서, 이 포인터가 가리키는 사람을 죽이고 포인터를 K-1번 앞으로 옮기는 방식으로 구현
- 한 사람이 죽을 때마다 포인터를 K-1번 옮기기 때문에, 전체 시간 복잡도는 ***O(NK)***
```C++
// 코드 18.2 연결 리스트를 이용한 조세푸스 문제의 구현

void josephus(int n, int k) {
    // 리스트 준비
    list<int> survivors;
    for(int i = 1; i <= n; ++i) survivors.push_back(i);
    // 이번에 죽을 사람을 나타내는 포인터
    list<int>::iterator kill = survivors.begin();
    while(n > 2) {
        // 첫 번째 사람이 자살. erase()는 지운 원소의 다음 원소를 반환
        kill = survivors.erase(kill);
        if (kill == survivors.end()) kill = survivors.begin();
        --n;
        // k-1번 다음 사람으로 옮김
        for(int i = 0; i < k-1; ++i) {
            ++kill;
            if(kill == survivors.end()) kill = survivors.begin();
        }
    }
    count << survivors.front() << " " << survivors.back() << endl;
}
```