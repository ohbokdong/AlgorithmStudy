# 23. 우선순위 큐와 힙
## 23.1. 도입
### 우선순위 큐란
- 트리와 밀접하게 연관된 자료구조
- 순서대로 기다리고 있는 자료들을 저장하는 자료구조
- `큐`와 비슷하지만 `우선순위`가 가장 높은 자료가 가장 먼저 꺼내진다는 차이가 있음
- 수행할 작업이 여러 개 있고 시간이 제한되어 있을 때 우선순위가 높은 것부터 수행한다거나 하는 일이 자주 있음

### 우선순위 큐의 구현
- 연결 리스트나 배열에 원소들을 모두 집어놓고 원소를 꺼낼 때 마다 모든 원소를 순회하며 우선순위가 가장 높은 원소를 찾을 수 있음 (간단한 구현방법)
    - 이렇게 구현할 경우 원소를 추가하는 데 `O(1)`의 시간이, 원소를 꺼내는 데는 `O(N)`의 시간이 걸림
- 또는 `균형잡힌 이진 검색 트리`를 사용하여 구현할 수 있음
    - 원소들을 우선순위로 정렬해 두면 **최대 원소를 찾아 삭제하는 연산**, **새 원소를 삽입하는 연산**을 모두 `O(lgN)` 시간에 할 수 있음
- 우선순위 큐를 이진 검색 트리보다 훨씬 단순한 자료 구조로도 구현할 수 있는데, 대표적인 것이 `힙(heap)이라는 트리`를 활용하는 것
    - 힙은 `가장 큰 원소`를 찾는데 최적화된 형태의 이진 트리로, 힙을 사용하면 **새 원소를 추가하는 연산**과 **가장 큰 원소**를 꺼내는 연산을 모두 **O(lgN)** 시간에 수행할 수 있음
    - 힙을 사용하면 우선순위 큐를 아주 쉽게 구현 가능
        - 대부분의 프로그래밍 언어의 표준 라이브러리에 포함되어 있음

## 23.2 힙의 정의와 구현
- 힙은 특정한 규칙을 만족하도록 구성된 `이진 트리`
- 단순히 최대 원소를 가능한 한 빠르게 찾을 수 있는 방법으로 설계되었기 때문에 더 단순한 알고리즘으로도 효율적으로 동작할 수 있음
> ### 힙의 대소관계 규칙
> - 힙은 **부모 노드가 가진 원소가 항상 자식 노드가 가진 원소 이상**이어야 한다는 규칙이 있음 (`힙의 대소 관계 규칙`)
> 1. 힙에서 대소 관계 규칙은 이진 검색 트리와는 달리 부모 자식 관계에만 적용됨
> 2. 왼쪽 자식과 오른쪽 자식이 갖는 원소의 크기는 제한하지 않아야 함   
   
![7개의 정수를 저장하는 힙의 예](https://github.com/ohbokdong/AlgorithmStudy/blob/main/summary/week12/images/heaps_rules.jpeg)   
- 힙의 대소관계 규칙에 의하면 **트리에서 가장 큰 원소는 항상 트리의 루트에 들어가므로**, 최대 원소를 빨리 찾기를 원하는 힙의 목적에 잘 부합함
- 위 그림은 일곱 개의 정수를 저장하는 최대 힙의 예제를 보여줌 (모든 키 중의 최대 원소 32가 루트에 위치해 있는 것을 확인 가능)

> ### 힙의 모양 규칙
> - 대소 관계 규칙만으로는 이진 검색 트리의 문제였던 **트리가 한 쪽으로 기울어지는 일**을 막을 수 없음
> - 힙은 트리의 높이를 항상 일정하게 유지하기 위해 트리의 구조에 제약을 둠
> 1. 마지막 레벨을 제외한 모든 레벨에 노드가 꽉 차 있어야 함
> 2. 마지막 레벨에 노드가 있을 때는 항상 왼쪽부터 순서대로 채워져 있어야 함
   
### 힙의 모양 규칙을 어기는 이진 트리의 예
![힙의 모양 규칙을 어기는 이진 트리의 예](https://github.com/ohbokdong/AlgorithmStudy/blob/main/summary/week12/images/btree_breaks_the_rules.jpeg)   
- 노드를 비워둔 채 다음 레벨에 노드를 추가함
- 왼쪽부터 노드를 채워가지 않음
   
- 힙의 두 가지 모양 규칙을 모두 만족한다면 트리에 포함된 노드의 개수만으로 트리의 모양이 정해짐
    - ex) 7개의 원소가 들어있는 모든 힙은 모두 위 그림과 같은 형태를 가질 수밖에 없음
    - 또한 모양 규칙을 모두 만족할 때 힙의 높이는 `O(lgN)`이 됨
- 힙에서의 모양 규칙 엄격함 \> 대부분의 균형잡힌 이진 검색 트리에서 요구되는 조건 엄격함

### 배열을 이용한 힙의 구현
- 힙이 요구하는 굉장히 엄격한 모양 규칙은 힙 구현 시 장점으로 작용
    - 트리에 포함된 노드의 개수만 알면 트리 전체의 구조를 알 수 있음
- 대부분의 힙 구현은 이 점을 최대한 이용, **배열 하나로 전체 트리를 표현함**   
![힙의 노드들을 배열의 원소와 일대일 대응하기](https://github.com/ohbokdong/AlgorithmStudy/blob/main/summary/week12/images/node_mapping_to_element.jpeg)   
- 위 그림 (a)처럼 텅 빈 힙에 원소를 삽입하면 맨 윗 레벨의 왼쪽 끝부터 노드들이 순서대로 추가됨
- 원소가 들어가는 순서대로 일차원 배열 A[]의 각 원소와 힙의 노드들을 일대일 대응해보면 (b)를 얻을 수 있음
    - A\[i\]에 대응되는 노드의 왼쪽 자손은 A\[2 X i + 1\]에 대응됨
    - A\[i\]에 대응되는 노드의 오른쪽 자손은 A\[2 X i + 2\]에 대응됨
    - A\[i\]에 대응되는 노드의 부모는 A\[(i - 1) / 2\]에 대응됨 (나눗셈 결과 내림처리)
- 힙의 모양 규칙에 의해, 힙에 n개의 노드가 있을 때 이 노드들은 A\[0\] ~ A\[n - 1\]까지 순차적으로 대응됨

#### 힙의 생성
```C++
vector<int> heap;
```

### 새 원소의 삽입
![힙에서 원소의 삽입 과정](https://github.com/ohbokdong/AlgorithmStudy/blob/main/summary/week12/images/insert_of_heap.png)   
1. 루트가 가진 원소와 새 원소 비교
2. 둘 중 더 큰 원소가 루트를 차지하고 다른 원소가 아래로 밀려 내려감
```C++
// 코드 23.1 정수 원소를 갖는 최대 힙에 새 원소 삽입

// 정수를 담는 최대 힙 heap에 새 원소 newValue 삽입
void push heap(vector<int>& heap, int newValue) {
    // 힙의 맨 끝에 newValue 삽입
    heap.push_back(newValue);
    // 현재 newValue의 위치
    int idx = heap.size() - 1;
    // 루트에 도달하거나 newValue 이상의 원소를 가진 조상을 만날 때까지
    while(idx > 0 && heap[(idx - 1) / 2] < heap[idx]) {
        swap(heap[idx], heap[(idx - 1) / 2]);
        idx = (idx - 1) / 2;
    }
}
```

### 최대 원소 꺼내기
![힙에서 최대 원소를 지우는 과정](https://github.com/ohbokdong/AlgorithmStudy/blob/main/summary/week12/images/delete_in_heap.jpeg)   
1. 배열의 첫 원소 확인(= 힙에서 최대 원소 찾기)
2. 힙의 마지막에 있는 노드(리프) 루트에 덮어 씌우기
3. 원소의 대소 관계 조건 만족시키기
```C++
// 코드 23.2 정수 원소를 갖는 최대 힙에서 최대 원소 삭제

// 정수를 담는 최대 힙 heap에서 heap[0]을 제거
void pop_heap(vector<int>& heap) {
    // 힙의 맨 끝에서 값을 가져와 루트에 덮어씌움
    heap[0] = heap.back();
    heap.pop_back();
    int here = 0;
    while(true) {
        int left = here * 2 + 1, right = here * 2 + 2;
        // 리프에 도달한 경우 
        if(left >= heap.size()) break;
        // heap[here]가 내려갈 위치를 찾는다.
        int next = here;
        if(heap[next] < heap[left])
            next = left;
        if(right < heap.size() && heap[next] < heap[right])
            next = right;
        if (next == here) break;
        swap(heap[here], heap[next]);
        here = next;
    }
}
```

### 다른 연산들
- 힙을 만드는 연산
    - N개의 원소를 텅 빈 힙에 순서대로 삽입해야 할 때 쓸 수 있음
    - 이 길이 N인 배열에 저장한 뒤 힙을 만드는 연산을 수행하면 `O(N)`만에 힙으로 만들어 줌
- `힙 정렬(Heapsort)`
    - 힙에서 원소들을 꺼낼 때 항상 정렬된 순서대로 반환된다는 점을 이용
    - 주어진 배열을 힙으로 만든 뒤 모든 원소들을 꺼내서 반환 순서대로 배열하면 정렬 결과가 됨
    - 최악의 경우에도 `O(NlgN)` 시간 복잡도만을 요구함
- 이미 힙에 들어있는 원 소 중 하나를 증가시키기
    - 힙을 이용하여 우선순위 큐를 구현할 때 유용하게 사용 됨
    - 이미 큐에 들어 있는 어느 작업의 우선순위가 높아졌을 때 변경된 원소를 위로 올려주는 방식으로 구현(새 원소 삽입과 비슷)
    - 위 작업을 위해 각 원소가 힙의 어디에 위치하는지를 별도의 배열에 유지해야 하는 등 구현이 번거로워 대부분의 표준 라이브러리에서 지원하지 않음

## 23.3 문제: 변화하는 중간 값
- 한 수열의 중간 값(median)은 이 수열을 정렬했을 때 가운데 오는 값
- 예를 들어 {3, 1, 5, 4, 2}를 정렬했을 때 가운데 오는 값은 3
- 수열의 길이가 **짝수일 때는 가운데 있는 두 값 중 보다 작은 것을 수열의 중간 값**이라고 정의
- 한 수열의 중간 값은 수열에 새로운 수가 추가될 때마다 바뀔 수 있음
- 텅 빈 수열에서 시작해서 각 수가 추가될 때마다 중간 값을 계산하는 프로그램을 작성하는 문제

### 입력 생성
- 입력의 크기가 큰 관계로, 이 문제에서는 수열을 입력받는 대신 다음과 같은 식을 통해 프로그램 내에서 직접 생성함
```
A[0] = 1983
A[i] = (A[i-1] x a + b) mod 20090711
```
- a와 b는 입력에 주어지는 상수이며 이 문제의 해법은 입력을 생성하는 방식과는 아무 상관이 없음

### 입력
- 입력 파일의 첫 줄에는 테스트 케이스의 수 C(1 ≤ C ≤ 20)가 주어지고, 그 후 C줄에 각 세 개의 정수로 수열의 길이 N(1 ≤ N ≤ 200,000), 그리고 수열을 생성하는 데 필요한 두 정수 
a, b(0 ≤ a, b ≤ 10000)가 주어짐

### 출력
- 각 테스트 케이스마다 한 줄에 N개의 중간 값의 합을 20090711로 나눈 나머지를 출력함

### 예제 입력
```
3
10 1 0
10 1 1
10000 1273 4936
```

### 예제 출력
```
19830
19850
2448920
```

## 23.4 풀이: 변화하는 중간 값
- `균형잡힌 이진 검색 트리`를 사용하여 해결가능
- 22.6절에서 사용한 트립을 사용하면 새 원소를 추가하는 작업과 k번째 원소를 찾는 작업을 모두 `O(lgN)`에 할 수 있음
- 단, `트립 구현 코드`를 작성해야 하므로 균형 잡힌 이진 검색 트리를 직접 구현하기가 영 귀찮음

```C++
// 코드 23.3 변화하는 중간 값 문제를 트립을 사용해 풀기

// mg가 생성하는 첫 n개의 난수를 수열에 추가하며 중간 값을 구함
int runningMedian(int n, RNG rng) {
    Node* root = NULL;
    int ret = 0;
    for(int cnt = 1; cnt <= n; ++cnt) {
        root = insert(root, new Node(rng.next()));
        int median = kth(root, (cnt + 1) / 2) -> key;
        ret = (ret + median) % 20090711;
    }
    return ret;
}
```

### 이진 검색 트리를 사용하지 않고 문제 풀기
- 주어진 수열의 숫자들을 두 묶음으로 나누어 풀 수 있음
- 숫자들을 정렬한 뒤 앞의 절반을 최대 합에, 뒤의 절반을 최소 합에 넣도록 함
- 수열의 길이가 홀수라면 최대 힙에 숫자를 하나 더 넣음
```
// 위 과정을 요약한 불변식
1. 최대 힙의 크기는 최소 힙의 크기와 같거나, 하나 더 크다.
2. 최대 힙의 최대 원소는 최소 힙의 최소 원소보다 작거나 같다
```
- 위 불변식으로 문제를 풀면 이 수열의 중간 값은 항상 최대 힙의 루트에 있게 됨
- 이 불변식들은 새로운 숫자가 추가되었을 때에도 간단히 유지할 수 있음

```C++
// 코드 23.4 힙을 이용해 변화하는 중간 값 문제를 해결하는 함수의 구현

int runningMedian(int n, RNG rng) {
    priority_queue<int, vector<int>, less<int> > maxHeap;
    priority_queue<int, vector<int>, greater<int> > minHeap;
    int ret = 0;
    // 반복문 불변식
    // 1. maxHeap의 크기는 minHeap의 크기와 같거나 1 더 큼
    // 2. maxHeap.top() <= minHeap.top()
    for(int cnt = 1; cnt <= n; ++cnt) {
        // 우선 1번 불변식부터 만족시킴
        if(maxHeap.size() == minHeap.size())
            maxHeap.push(rng.next());
        else
            minHeap.push(rng.next());
        // 2번 불변식이 깨졌을 경우 복구
        if(!minHeap.empty() && !maxHeap.empty() && minHeap.top() < maxHeap.top()) {
            int a = maxHeap.top(), b = minHeap.top();
            maxHeap.pop(); minHeap.pop();
            maxHeap.push(b);
            minHeap.push(a);
        }
        ret = (ret + maxHeap.top()) % 20090711;
    }
    return ret;
}
```
- `runningMedian()`의 시간 복잡도 또한 `O(NlgN)`
    - for문 내부의 수행 시간을 힙의 추가와 삭제 연산이 지배하고 있기 때문
    - 시간 복잡도는 같지만, 힙은 대개 배열로 구현되기 때문에 노드들을 접근하기 위해 포인터를 따라가야 하는 트립보다 훨씬 빠름