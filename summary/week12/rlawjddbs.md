# 23. 우선순위 큐와 힙
## 23.1. 도입
### 우선순위 큐란
- 트리와 밀접하게 연관된 자료구조
- 순서대로 기다리고 있는 자료들을 저장하는 자료구조
- `큐`와 비슷하지만 `우선순위`가 가장 높은 자료가 가장 먼저 거내진다는 차이가 있음
- 수행할 작업이 여러 개 있고 시간이 제한되어 있을 때 우선순위가 높은 것부터 수행한다거나 하는 일이 자주 있음

### 우선순위 큐의 구현
- 연결 리스트나 배열에 원소들을 모두 집어놓고 원소를 꺼낼 때 마다 모든 원소를 순회하며 우선순위가 가장 높은 원소를 찾을 수 있음 (간단한 구현방법)
    - 이렇게 구현할 경우 원소를 추가하는 데 `O(1)`의 시간이, 원소를 꺼내는 데는 `O(N)`의 시간이 걸림
- 또는 `균형잡힌 이진 검색 트리`를 사용하여 구현할 수 있음
    - 원소들을 우선순위로 정렬해 두면 **최대 원소를 찾아 삭제하는 연산**, **새 원소를 삽입하는 연산**을 모두 `O(lgN)` 시간에 할 수 있음
- 우선순위 큐를 이진 검색 트리보다 훨씬 단순한 자료 구조로도 구현할 수 있는데, 대표적인 것이 `힙(heap)이라는 트리`를 활용하는 것
    - 힙은 `가장 큰 원소`를 찾는데 최적화된 형태의 이진 트리로, 힙을 사용하면 **새 원소를 추가하는 연산**과 **가장 큰 원소**를 꺼내는 연산을 모두 **O(lgN)** 시간에 수행할 수 있음
    - 힙을 사용하면 우선순위 큐를 아주 쉽게 구현 가능
        - 대부분의 프로그래밍 언어의 표준 라이브러리에 포함되어 있음

## 23.2 힙의 정의와 구현
- 힙은 특정한 규칙을 만족하도록 구성된 `이진 트리`
- 단순히 최대 원소를 가능한 한 빠르게 찾을 수 있는 방법으로 설계되었기 때문에 더 단순한 알고리즘으로도 효율적으로 동작할 수 있음
> ### 힙의 대소관계 규칙
> - 힙은 **부모 노드가 가진 원소가 항상 자식 노드가 가진 원소 이상**이어야 한다는 규칙이 있음 (`힙의 대소 관계 규칙`)
> 1. 힙에서 대소 관계 규칙은 이진 검색 트리와는 달리 부모 자식 관계에만 적용됨
> 2. 왼쪽 자식과 오른쪽 자식이 갖는 원소의 크기는 제한하지 않아야 함   
   
![7개의 정수를 저장하는 힙의 예](https://github.com/ohbokdong/AlgorithmStudy/blob/main/summary/week12/images/heaps_rules.jpeg)   
- 힙의 대소관계 규칙에 의하면 **트리에서 가장 큰 원소는 항상 트리의 루트에 들어가므로**, 최대 원소를 빨리 찾기를 원하는 힙의 목적에 잘 부합함
- 위 그림은 일곱 개의 정수를 저장하는 최대 힙의 예제를 보여줌 (모든 키 중의 최대 원소 32가 루트에 위치해 있는 것을 확인 가능)

> ### 힙의 모양 규칙
> - 대소 관계 규칙만으로는 이진 검색 트리의 문제였던 **트리가 한 쪽으로 기울어지는 일**을 막을 수 없음
> - 힙은 트리의 높이를 항상 일정하게 유지하기 위해 트리의 구조에 제약을 둠
> 1. 마지막 레벨을 제외한 모든 레벨에 노드가 꽉 차 있어야 함
> 2. 마지막 레벨에 노드가 있을 때는 항상 왼쪽부터 순서대로 채워져 있어야 함
   
### 힙의 모양 규칙을 어기는 이진 트리의 예
![힙의 모양 규칙을 어기는 이진 트리의 예](https://github.com/ohbokdong/AlgorithmStudy/blob/main/summary/week12/images/btree_breaks_the_rules.jpeg)   
- 노드를 비워둔 채 다음 레벨에 노드를 추가함
- 왼쪽부터 노드를 채워가지 않음
   
- 힙의 두 가지 모양 규칙을 모두 만족한다면 트리에 포함된 노드의 개수만으로 트리의 모양이 정해짐
    - ex) 7개의 원소가 들어있는 모든 힙은 모두 위 그림과 같은 형태를 가질 수밖에 없음
    - 또한 모양 규칙을 모두 만족할 때 힙의 높이는 `O(lgN)`이 됨
- 힙에서의 모양 규칙 엄격함 \> 대부분의 균형잡힌 이진 검색 트리에서 요구되는 조건 엄격함

### 배열을 이용한 힙의 구현
- 힙이 요구하는 굉장히 엄격한 모양 규칙은 힙 구현 시 장점으로 작용
    - 트리에 포함된 노드의 개수만 알면 트리 전체의 구조를 알 수 있음
- 대부분의 힙 구현은 이 점을 최대한 이용, **배열 하나로 전체 트리를 표현함**   
![힙의 노드들을 배열의 원소와 일대일 대응하기](https://github.com/ohbokdong/AlgorithmStudy/blob/main/summary/week12/images/btree_breaks_the_rules.jpeg)   
- 위 그림 (a)처럼 텅 빈 힙에 원소를 삽입하면 맨 윗 레벨의 왼쪽 끝부터 노드들이 순서대로 추가됨
- 원소가 들어가는 순서대로 일차원 배열 A[]의 각 원소와 힙의 노드들을 일대일 대응해보면 (b)를 얻을 수 있음
    - A\[i\]에 대응되는 노드의 왼쪽 자손은 A\[2 X i + 1\]에 대응됨
    - A\[i\]에 대응되는 노드의 오른쪽 자손은 A\[2 X i + 2\]에 대응됨
    - A\[i\]에 대응되는 노드의 부모는 A\[(i - 1) / 2\]에 대응됨 (나눗셈 결과 내림처리)
- 힙의 모양 규칙에 의해, 힙에 n개의 노드가 있을 때 이 노드들은 A\[0\] ~ A\[n - 1\]까지 순차적으로 대응됨

#### 힙의 생성
```C++
vector<int> heap;
```

### 새 원소의 삽입
![힙에서 원소의 삽입 과정](https://github.com/ohbokdong/AlgorithmStudy/blob/main/summary/week12/images/node_mapping_to_element.jpeg)   
1. 루트가 가진 원소와 새 원소 비교
2. 둘 중 더 큰 원소가 루트를 차지하고 다른 원소가 아래로 밀려 내려감
```C++
// 코드 23.1 정수 원소를 갖는 최대 힙에 새 원소 삽입

// 정수를 담는 최대 힙 heap에 새 원소 newValue 삽입
void push heap(vector<int>& heap, int newValue) {
    // 힙의 맨 끝에 newValue 삽입
    heap.push_back(newValue);
    // 현재 newValue의 위치
    int idx = heap.size() - 1;
    // 루트에 도달하거나 newValue 이상의 원소를 가진 조상을 만날 때까지
    while(idx > 0 && heap[(idx - 1) / 2] < heap[idx]) {
        swap(heap[idx], heap[(idx - 1) / 2]);
        idx = (idx - 1) / 2;
    }
}
```

### 최대 원소 꺼내기
![힙에서 최대 원소를 지우는 과정](https://github.com/ohbokdong/AlgorithmStudy/blob/main/summary/week12/images/delete_in_heap.jpeg)   
1. 배열의 첫 원소 확인(= 힙에서 최대 원소 찾기)
2. 힙의 마지막에 있는 노드(리프) 루트에 덮어 씌우기
3. 원소의 대소 관계 조건 만족시키기
```C++
// 코드 23.2 정수 원소를 갖는 최대 힙에서 최대 원소 삭제

// 정수를 담는 최대 힙 heap에서 heap[0]을 제거
void pop_heap(vector<int>& heap) {
    // 힙의 맨 끝에서 값을 가져와 루트에 덮어씌움
    heap[0] = heap.back();
    heap.pop_back();
    int here = 0;
    while(true) {
        int left = here * 2 + 1, right = here * 2 + 2;
        // 리프에 도달한 경우 
        if(left >= heap.size()) break;
        // heap[here]가 내려갈 위치를 찾는다.
        int next = here;
        if(heap[next] < heap[left])
            next = left;
        if(right < heap.size() && heap[next] < heap[right])
            next = right;
        if (next == here) break;
        swap(heap[here], heap[next]);
        here = next;
    }
}
```

