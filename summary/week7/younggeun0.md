## 동적 계획법(Dynamic Programming) 2/2

---

### 8.9 문제 : Quantization p244 참고

* Quantization(양자화)는 더 넓은 범위를 갖는 값들을 작은 범위를 갖는 값들로 근사해 표현함으로써 자료를 손실 압축하는 것
  * 양자화 예시
    * 16비트 JPG 파일을 4컬러 GIF 파일로 변환하는 작업
    * 키가 161, 164, 178, 184인 사람들을 160대 둘, 170 하나, 180대 하나로 축약표현하는 것
* 1000 이하의 자연수들로 구성된 수열을 s가지의 자연수만을 사용하도록 양자화할 때 숫자별 오차 제곱의 합의 최소화치를 구하는 문제
  * 예시 - 수열 1 2 3 4 5
    * 2 2 3 3 3으로 양자화 했을 때
      * 각 숫자별 오차는 -1, 0, 0, 1, 2이고, 오차 제곱의 합은 1+0+0+1+4=6이 됨
    * 2 2 2 4 4로 양자화 했을 때
      * 각 숫자별 오차는 -1, 0, -1, 0, 1이고, 오차 제곱의 합은 1+0+1+0+1=3이 됨
  * 입력
    * 테스트 케이스 수 C(1<=C<=50)
    * 수열의 길이 n(1<=n<=100)
    * 사용할 숫자의 수 s(1<=s<=10)
    * n개의 정수 수열의 숫자들(수열의 모든 수는 1000이하의 자연수)
  * 출력
    * 각 테스트 케이스마다 한 줄에 주어진 수열을 s개의 수로 양자화할 때 오차 제곱의 합의 최소치를 출력

### 8.10 풀이 : Quantization

#### 하던 대로 안됨

* 앞에 풀었던 문제들처럼 재귀적인 해법으로는 풀 수 없음
  * == 양자화된 결과 수열을 재귀적으로 구해 최소 오차 제곱을 구해 반환하는 방법

> quantize(A) = A에 속한 수를 양자화해서 얻을 수 있는 최소 오차 제곱의 합

* 이 문제에서는 사용할 수 있는 숫자의 가짓수에 제한이 존재(s)
  * 남은 문제를 재귀적으로 해결할 때 지금까지 사용한 숫자들을 무시할 수 없음, 이미 s가지 숫자를 다 쓴 상태면 이 중 하나의 숫자를 선택해야 하기 때문
  * == 최적 부분 조건이 성립하지 않음
* quantize()는 남은 숫자들만이 아니라 이전 숫자들은 어떤 숫자로 양자화했는지 또한 알아야 함
  * 때문에 지금까지 사용한 숫자들의 집합 또는 입력으로 받아야 함

> quantize(A, U) = U가 지금까지 한 번 이상 사용한 숫자들의 집합일 때 A에 속한 수를 양자화해서 얻을 수 있는 최소 오차 제곱의 합

* 이렇게 변경한 quantize함수는 A의 첫 번째 숫자를 어떻게 표현할지 결정하고 나머지를 재귀호출해서 해결하게 됨
  * 그러나 이런 완전 탐색 코드는 엄청나게 많은 수의 답을 만들게 됨(n이 1000이고 U가 10이라 가정하면 앞으로 990개가 추가로 n번의 재귀호출로 완전 탐색을 하게됨 ...(안끝남))

#### 답의 형태 제한하기

* 이와 같이 **부분 문제의 개수가 너무 많을 땐 답이 항상 어떤 구조를 가질 것이라고 예측하고 그것을 강제하는 방법을 사용해볼 수 있음**
  * 이 문제에서는 주어진 수열을 정렬하면, 같은 숫자로 양자화되는 숫자들은 항상 인접해 있음을 알 수 있음
* 우선 입력에서 주어진 수를 정렬, 인접한 숫자끼리 묶음으로 적절히 분할, 각 묶음을 한 숫자로 표현 => 오류를 최소화

```c++
{1, 4, 6, 744, 755, 777,890, 897, 902}

{1, 4, 6}, {744, 755, 777, 890, 897, 902}

{4, 4, 4}, {759, 759, 759}, {896, 896, 896}
```

* 이렇게 되면 이 문제는 주어진 수열을 s개의 묶음으로 나누는 문제가 됨
  * 재귀호출에서 첫 묶음의 크기가 얼마인지를 결정하면 됨
  * 첫 묶음의 크기가 x라고 하면 나머지 n-x개의 숫자를 s-1개의 묶음으로 나누면 됨
  * 이 때 나머지 s-1 묶음의 오류 합이 최소여야 전체도 최소 오류이므로 최적 부분 구조 또한 성립

> quantize(from, parts) = from번째 이후의 숫자들을 parts개의 묶음으로 묶을 때 최소 오류 제곱 합을 반환하는 함수

> minError(a,b)는 a번째 숫자부터 b번째 숫자까지 하나의 수로 표현했을 때의 최소 오류를 반환

* 첫 번째 묶음의 크기가 size일 때 최소 오류는 minError(from, from + size -1) + quantize(from + size, parts - 1)이 됨
  * 점화식은 p247 참고

#### 한 개의 구간에 대한 답 찾기, 구현 생략(p248~251)

### 8.11 경우의 수와 확률

* **동적 계획법은 최적화 문제를 풀기 위해 고안되었으나 경우의 수를 세거나 확률을 계산하는 문제에도 흔하게 사용됨**
  * 경우의 수를 계산하는 문제는 많은 경우 재귀적인 특징을 갖기 때문(ex. 이항 계수 문제)

#### 오버플로에 유의하기

* 대개 경우의 수를 세는 문제에서 답은 입력의 크기에 대해 지수적으로 증가
  * 때문에 일반적으로 32비트 정수형의 한계를 초과하기 십상
  * 때문에 대부분의 문제에서는 답을 어떤 수 M으로 나눈 나머지를 출력하기를 요구하는 식으로 이런 현상을 해결함
    * 모듈라 연산(나머지 연산)에 관련된 식을 미리 알아두는게 좋다고 함(14.8절)
      * [나머지 - wiki](https://ko.wikipedia.org/wiki/%EB%82%98%EB%A8%B8%EC%A7%80)

#### 예제 : 타일링 방법의 수 세기 p252 참고

* 2\*n 크기의 사각형을 2*1 크기의 타일로 채우는 방법의 수를 계산하는 문제
  * 타일들은 서로 겹쳐서는 안 되고, 90도로 회전해서 쓸 수 있음(p252, n=5 일 때 그림 8.7 참고)

* **풀이 접근법**
1. 완전 탐색을 이용 모든 답을 만들면서 개수를 세어보는 함수를 작성
2. 메모이제이션을 이용해 동적 계획법 알고리즘으로 변경

* 재귀호출을 이용해 모든 타일링 방법을 만들려면 각 타일링 방법을 여러 조각으로 쪼개고 재귀 호출될 때마다 한 조각씩 만들어 나가면 됨
  * 2*n 사각형을 채우는 모든 방법들은 맨 왼쪽 세로줄이 어떻게 채워져 있느냐로 나눌 수 있음
    * 세로줄 한 개 또는 두 개의 가로 타일
      * **이 두 가지 분류는 타일링하는 방법을 모두 포함**
      * **두 가지 분류에 모두 포함되는 타일링 방법은 없음**
      * 위 두 가지 속성은 경우의 수를 셀 때 항상 확인해야 하는 조건
* **점화식**
  * 이전 부분들을 어떻게 덮었는지에 관한 정보는 들어가 있지 않음

> tiling(n) = 2*n 크기의 사각형을 타일로 덮는 방법을 반환

> tiling(n) = tiling(n-1) + tiling(n-2)

