# 8장 동적계획법 2/2

## 8.11 경우의 수와 확률
경우의 수를 계산하는 문제는 많은 경우 재귀적인 특성을 가지고 있기 때문에 동적 계획법을 활용할 수 있음

### 오버플로에 유의하기
경우의 수를 세는 문제에서 32비트 정수형의 한계를 초과하기 쉬우므로 주의할 것.
### 예제: 타일링 방법의 수 세기 (문제ID: TILING2)
2xn 크기의 사각형을 2x1 크기의 타일로 채우는 방법의 수를 계산하는 문제   
완전 탐석을 이용해 모든 답을 만들면서 개수를 세어보는 함수를 작성한 뒤, 메모이제이션을 이용해 동적 계획법 알고리즘으로 바꾼다.   
재귀호출을 이용해 모든 타일링 방법을 만들려면 각 타일링 방법을 여러 조각으로 쪼개고 함수가 재귀 호출될 때마다 한 조각씩 만들어 나가면 된다.
   
맨 왼쪽 세로줄이 어떻게 채워져 있느냐에 따라 나눌 수 있다.
- 이 두가지 분류는 타일링하는 방법을 모두 포함
- 두 가지 분류에 모두 포함되는 타일링 방법은 없다.

따라서 각 단계에서 이 세로줄을 세로 타일 하나로 덮을 것인지, 가로 타일 두개로 덮을 것인지를 결정하기만 하면 된다.   
남은 공간은 2 x (n - 1), 2 x (n - 2)크기의 사각형이 되므로
이를 재귀호출을 이용해 계산할 수 있음

```C++
//코드 8.16 타일링의 수를 세는 동적 계획법 알고리즘

const int MOD = 100000007;
int cache[101];
//2*width 크기의 사각형을 채우는 방법의 수를 MOD로 나눈 나머지를 반환한다.
int tiling(int width) {
  // 기저 사례: width가 1 이하일 때
  if (width <= 1) return 1;
  // 메모이제이션
  int& ret = cache[width];
  if(ret != -1) return ret;
  return ret = (tiling(width-2)) + tiling(width-1) % MOD;
}
```

### 예제: 우물을 기어오르는 달팽이
확률을 계산하는 문제에도 동적 계획법을 써먹을 수 있음   
문제: 깊이가 n 미터인 우물의 맨 밑바닥에 달팽이가 있습니다.   
비가오는 날: 2m 가능   
맑은 날: 1m 가능   
앞으로 m 일간 비가 올 확률은 정확히 50% 일 때, m일 안에 달팽이가 우물 끝까지 올라갈 확률은?

**경우의 수로 확률 계산하기**   
비가 오거나, 안오거나 이므로 2<sup>m<sup>   

**완전 탐색 알고리즘**   
최대 n*m개의 부분 문제만을 갖기 때문에 메모이제이션 적용 가능
```C++
// 코드 8.18 우물을 기어오르는 달팽이 문제를 해결하는 동적 계획법 알고리즘
int n, m;
int cache[MAX_N][2*MAX_N+1];
// 달팽이가 days일 동안 climbed미터를 기어올라 왔다고 할 때,
// m일 전까지 n미터를 기어올라갈 수 있는 경우의 수
int climb(int days, int climbed) {
  // 기저 사례: m일이 모두 지난 경우
  if(days == m) return climbed >= n ? 1 : 0;
  // 메모이제이션
  int& ret = cache[days][climbed];
  if(ret != -1) return ret;
  return ret = climb(days+1, climbed+1) + climb(days+1, clibed+2);
}
```

### 예제: 장마가 찾아왔다 
장마로 인해 비가 올 확률이 50%에서 75%로 상승. 날씨의 조합마다 출현할 확률이 달라질 수 있기 때문에 경우의 수를 계산하지 않고 직접 확률을 계산   
0.25와 0.75로 나눠서 경우의 수를 구하고 그 합을 구한다.
#### **경우의 수 계산하기 레시피**
1. 완전 탐색 알고리즘을 설계 - 재귀 호출의 각 단계에서 고르는 각 선택지에 다음과 같은 속성이 성립해야 함
a) 모든 경우는 이 선택지들에 포함됨 b) 어떤 경우도 두 개 이상의 선택지에 포함되지 않음
2. 이전 조각에서 결정한 요소들에 대한 입력을 없애거나 변형해서 줄인다.
3. 메모이제이션을 적용
