## 코딩과 디버깅에 관하여

---

### 3.1 코딩의 중요성을 간과하지 말라

* 코딩은 어떤 문제를 풀 때나 항상 필요하므로 가장 중요
* 빨리 코드를 작성하기보다 읽기 쉬운 코드를 작성하는 것이 중요

### 3.2 좋은 코드를 짜기 위한 원칙

#### 간결한 코드를 작성하기

* 코드가 짧을수록 오타나 단순한 버그가 생길 우려가 줄고 디버깅이 쉽기 때문
* **프로그래밍 대회**에서 유용한 방법들 (일반적인 경우 아님)
  * 전역 변수의 광범위한 사용
  * C/C++ 매크로를 사용해 간결한 코드 작성(`흑마법..`)

```c++
#define FOR(i, n) for(int i=0; i< (n); i++)

bool hasDuplicate(const vector<int>& array) {
  FOR(i, array.size())
    FOR(j, i)
      if (array[i] == array[j])
        return true;

  return false;
}
```

#### 적극적으로 코드 재사용하기

* 간결한 코드를 작성하기 위한 가장 직접적인 방법은 코드 모듈화
  * 같은 코드가 반복된다면 이들을 함수나 클래스로 분리해 재사용
* 프로그래밍 대회에서는 실무처럼 분리 원칙을 적용하기 힘듦
  * 제한된 시간과 작성된 코드의 용도가 하나인 경우가 많기 떄문

#### 표준 라이브러리 공부하기

* 프로그래밍대회에서 가장 자주 저지르는 실수는 큐나 스택과 같은 자료구조, 혹은 정렬 등의 기초적인 알고리즘을 직접 작성하는 것
* 언어의 문자열, 동적 배열, 스택, 큐, 리스트, 딕셔너리 등의 자료 구조, 그리고 정렬 등의 표준적인 알고리즘 구현 사용법을 반드시 잘 알아둬야 함

#### 항상 같은 형태로 프로그램을 작성하기

* 같은 코드를 다양한 방식으로 짜보는 것은 자신이 가장 알아보기 쉬운 코드를 작성하는 데 도움이 됨
  * 하지만 대회에서는 시간에 쫒기기 때문에 자주 작성하는 알고리즘이나 코드 등에 대해서는 한 번 검증된 코드를 작성하고 이것만을 꾸준히 사용할 필요가 있음
  * 도구가 아니라 문제에 집중하기 위함

#### 일관적이고 명료한 명명법 사용하기

* 모호하지 않은 변수명과 함수명을 사용해야 하고, 사용하는 언어의 표준 라이브러리에서 사용하는 명명 규약(Naming Convention)을 익혀야 함

#### 모든 자료를 정규화해서 저장하기

* 좋은 코드는 정규화하여 같은 자료를 두 가지 형태로 저장하지 않음
  * 시간대, 각도, 인코딩 등
* 정규화는 프로그램이 자료를 입력받거나 계산하자마자 곧장 이루어지는게 이상적

#### 코드와 데이터를 분리하기

* 코드의 논리와 상관없는 데이터는 가능한 분리하는 것이 좋음
  
```js
// Bad
var getMonthName = function(month) {
  if (month == 1) return "Jan";
  if (month == 2) return "Feb";
  ...
  return "Dec";
}

// Good
const months[] = ["Jan", "Fe", ... "Dec"];
```

### 3.2 자주 하는 실수

#### 산술 오버플로

* 계산 과정에서 변수의 표현 범위를 벗어나는 값을 사용하는 산술 오버플로

#### 배열 범위 밖 원소에 접근

* 배열 범위 밖의 원소에 접근하는 오류

#### 일관되지 않은 범위 표현 방식 사용하기

* 대부분의 프로그래밍 언어는 반 열린 구간(half-open interval)을 사용
  * n개의 원소를 갖는 배열 a의 첫 번째 원소는 a[0], 마지막 원소는 a[n-1]
    * 0 <= i < n-1
  * 닫힌 구간(closed interval) - \[2, 12] (2 <= i <= 12)
  * 열린 구간(open interval) - \(2, 12) (2 < i < 12)
* 프로그램 내에서 한 가지 방법으로만 범위를 표현하는게 좋음(프로그래밍 언어가 지원하는 범위 표현 방식)
  
#### Off-By-One 오류

* 하나가 모자라거나 하나가 많아서 틀리는 코드의 오류들을 지칭
  * 정수배열 A[]가 주어질 때 A[i]부터 A[j]까지의 평균을 구할 때 합을 얼마로 나누어야 하는지?
    * 답은 j-i가 아닌 j-1+1
* Off-By-One 오류는 비교연산자를 혼동하거나 반 열린 구간과 닫힌 구간을 서로 혼용해 쓴 경우 발생
  * 최소 입력이 주어졌을 때 이 코드가 어떻게 동작할지를 되새겨 보면서 프로그램을 짜는 방법이 Off-By-One 오류 해결에 도움이 됨

#### 컴파일러가 잡아주지 못하는 상수 오타

* 변수명이나 함수명에서 오타를 낼 경우 컴파일러가 잡아줄 수 있으나 상수 오타를 낼 경우 찾기 쉽지 않음

#### 스택 오버플로

* 프로그램 실행 중 콜 스택(Call Stack)이 오버플로해서 프로그램이 강제종료되는 것
  * 대개 재귀 호출의 깊이가 너무 깊어져서 발생
* 대회참여 시 스택 허용량에 대해 알아 둘 필요가 있음

#### 다차원 배열 인덱스 순서 바꿔쓰기

* 2차원 이상 다차원 배열 사용 시 인덱스를 잘못 쓰는 경우가 발생가능
  * 가능한 특정 배열에 접근하는 위치를 하나로 통일하는게 좋음

#### 잘못된 비교 함수 작성

* 연산자 오버로딩 시 잘못된 비교 함수를 작성하면 다른 결과가 반환될 수 있음

#### 최소, 최대 예외 잘못 다루기

* 코드를 짤 때 가장 작은 입력과 가장 큰 입력에 대해 제대로 동작할지 생각해 보면 오류를 잡을 수 있는 경우가 많음

#### 연산자 우선순위 잘못 쓰기

* 연산자 우선순위에 따라 결과가 다를 수 있어 연산자 우선순위를 잘 기억해 두고 헷갈릴 경우 괄호로 감싸 우선순위를 맞춰줘야 함

#### 너무 느린 입출력 방식 선택

* 고수준 입출력 방식을 이용하면 코드는 간단해지지만 이에 따른 속도 저하도 클 수 있음
  * 입출력 양에 따라 입출력 방식을 선택해 주는 것이 좋음

#### 변수 초기화 문제

* 이전 입력에서 사용한 전역 변수 값을 초기화하지 않고 그대로 사용하는 것
  * 새 테스트 케이스를 처리할 때마다 변수들을 적절히 초기화하도록 신경써야 함

### 3.4 디버깅과 테스트

#### 디버깅에 관하여

* 프로그램 작성 후 원하는 결과와 다르면 개발 도구에서 제공하는 디버거로 디버깅을 함
  * 프로그래밍 대회에서는 디버거는 유용성이 제한됨
    * 대회에선 코드가 길지 않기 때문에 눈으로 디버깅하는 쪽이 더 빠른 경우가 많음
    * 재귀 호출이나 중복 반복문을 많이 사용하는 복잡한 코드는 디버거로 디버깅하기에 적당하지 않음
    * ACM-ICPC처럼 여러 명이 한 대의 컴퓨터를 사용하는 대회에선 디버거를 사용하면 다른 사람들이 아무것도 할 수 없음 
* 디버거 없이 버그를 찾아내는 연습을 하는게 좋음
  * 잘 분리된 기능적인 코드를 작성하면 디버거 없이 눈만으로도 검증하기 비교적 쉬움
  * 작은 입력에 대해 제대로 실행되나 확인하기
    * 예제 입력의 크기가 클 경우 실행 과정을 되짚어 가기가 어렵기 때문에 오동작하는 가장 작은 입력을 먼저 찾아내면 디버깅하기 쉬움
  * 단정문(Assertion) 사용하기
    * 단정문이란 주어진 조건이 거짓일 때 오류를 내고 프로그램을 강제 종료시키는 함수 또는 구문
  * 프로그램의 계산 중간 결과를 출력하기
* 위와 같은 과정을 거쳐도 문제를 못 찾으면 디버거를 사용해도 좋음
* 프로그램이 런타임 오류를 내고 종료하는 경우, 언어에서 스택 기록을 출력해주지 못하면 디버거를 사용해 어디서 왜 죽는지 확인할 수 있음

#### 테스트에 관하여

* 답안 작성 후 제출 전 가능한 많은 예제로 테스트 해보는게 좋음
* 스캐폴딩(Scaffolding)은 다른 코드를 개발할 때 뼈대를 잡기 위해 임시로 사용하는 코드를 뜻함
  * 스캐폴딩 기법을 활용하여 테스트를 자동화하는 코드를 작성해서 테스트 케이스를 많이 테스트해보면 좋음

### 3.5 변수 범위의 이해

#### 산술 오버플로

* 

#### 너무 큰 결과

#### 너무 큰 중간값

#### 너무 큰 '무한대' 값

#### 오버플로 피해가기

#### 자료형의 프로모션

### 3.6 실수 자료형의 이해

#### 실수 연산의 어려움

#### 실수와 근사값

#### IEEE 754 표준

#### 실수의 이진법 표기

#### 부동 소수점 표기

#### 실수 비교하기

#### 하나, 비교할 실수의 크기들에 비례한 오차 한도를 정한다

#### 둘, 상대 오차를 이용한다

#### 대소 비교

#### 정확한 사칙연산

#### 코드의 수치적 안정성 파악하기

#### 경고

#### 실수 연산 아예 하지 않기

### 3.7 더 읽을 거리




