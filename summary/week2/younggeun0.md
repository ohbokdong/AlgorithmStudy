## 코딩과 디버깅에 관하여

---

### 3.1 코딩의 중요성을 간과하지 말라

* 코딩은 어떤 문제를 풀 때나 항상 필요하므로 가장 중요
* 빨리 코드를 작성하기보다 읽기 쉬운 코드를 작성하는 것이 중요

### 3.2 좋은 코드를 짜기 위한 원칙

#### 간결한 코드를 작성하기

* 코드가 짧을수록 오타나 단순한 버그가 생길 우려가 줄고 디버깅이 쉽기 때문
* **프로그래밍 대회**에서 유용한 방법들 (일반적인 경우 아님)
  * 전역 변수의 광범위한 사용
  * C/C++ 매크로를 사용해 간결한 코드 작성(`흑마법..`)

```c++
#define FOR(i, n) for(int i=0; i< (n); i++)

bool hasDuplicate(const vector<int>& array) {
  FOR(i, array.size())
    FOR(j, i)
      if (array[i] == array[j])
        return true;

  return false;
}
```

#### 적극적으로 코드 재사용하기

* 간결한 코드를 작성하기 위한 가장 직접적인 방법은 코드 모듈화
  * 같은 코드가 반복된다면 이들을 함수나 클래스로 분리해 재사용
* 프로그래밍 대회에서는 실무처럼 분리 원칙을 적용하기 힘듦
  * 제한된 시간과 작성된 코드의 용도가 하나인 경우가 많기 떄문

#### 표준 라이브러리 공부하기

* 프로그래밍대회에서 가장 자주 저지르는 실수는 큐나 스택과 같은 자료구조, 혹은 정렬 등의 기초적인 알고리즘을 직접 작성하는 것
* 언어의 문자열, 동적 배열, 스택, 큐, 리스트, 딕셔너리 등의 자료 구조, 그리고 정렬 등의 표준적인 알고리즘 구현 사용법을 반드시 잘 알아둬야 함

#### 항상 같은 형태로 프로그램을 작성하기

* 같은 코드를 다양한 방식으로 짜보는 것은 자신이 가장 알아보기 쉬운 코드를 작성하는 데 도움이 됨
  * 하지만 대회에서는 시간에 쫒기기 때문에 자주 작성하는 알고리즘이나 코드 등에 대해서는 한 번 검증된 코드를 작성하고 이것만을 꾸준히 사용할 필요가 있음
  * 도구가 아니라 문제에 집중하기 위함

#### 일관적이고 명료한 명명법 사용하기

* 모호하지 않은 변수명과 함수명을 사용해야 하고, 사용하는 언어의 표준 라이브러리에서 사용하는 명명 규약(Naming Convention)을 익혀야 함

#### 모든 자료를 정규화해서 저장하기

* 좋은 코드는 정규화하여 같은 자료를 두 가지 형태로 저장하지 않음
  * 시간대, 각도, 인코딩 등
* 정규화는 프로그램이 자료를 입력받거나 계산하자마자 곧장 이루어지는게 이상적

#### 코드와 데이터를 분리하기

* 코드의 논리와 상관없는 데이터는 가능한 분리하는 것이 좋음
  
```js
// Bad
var getMonthName = function(month) {
  if (month == 1) return "Jan";
  if (month == 2) return "Feb";
  ...
  return "Dec";
}

// Good
const months[] = ["Jan", "Fe", ... "Dec"];
```

### 3.2 자주 하는 실수

#### 산술 오버플로

* 계산 과정에서 변수의 표현 범위를 벗어나는 값을 사용하는 산술 오버플로

#### 배열 범위 밖 원소에 접근

* 배열 범위 밖의 원소에 접근하는 오류

#### 일관되지 않은 범위 표현 방식 사용하기

* 대부분의 프로그래밍 언어는 `반 열린 구간(half-open interval)`을 사용
  * n개의 원소를 갖는 배열 a의 첫 번째 원소는 a[0], 마지막 원소는 a[n-1]
    * 0 <= i < n-1
  * `닫힌 구간(closed interval)` - \[2, 12] (2 <= i <= 12)
  * `열린 구간(open interval)` - \(2, 12) (2 < i < 12)
* 프로그램 내에서 한 가지 방법으로만 범위를 표현하는게 좋음(프로그래밍 언어가 지원하는 범위 표현 방식)
  
#### Off-By-One 오류

* `Off-By-One`은 하나가 모자라거나 하나가 많아서 틀리는 코드의 오류들을 지칭
  * 정수배열 A[]가 주어질 때 A[i]부터 A[j]까지의 평균을 구할 때 합을 얼마로 나누어야 하는지?
    * 답은 j-i가 아닌 j-1+1
* Off-By-One 오류는 비교연산자를 혼동하거나 반 열린 구간과 닫힌 구간을 서로 혼용해 쓴 경우 발생
  * 최소 입력이 주어졌을 때 이 코드가 어떻게 동작할지를 되새겨 보면서 프로그램을 짜는 방법이 Off-By-One 오류 해결에 도움이 됨

#### 컴파일러가 잡아주지 못하는 상수 오타

* 변수명이나 함수명에서 오타를 낼 경우 컴파일러가 잡아줄 수 있으나 상수 오타를 낼 경우 찾기 쉽지 않음

#### 스택 오버플로

* `스택 오버플로우(Stack Overflow)`는 프로그램 실행 중 콜 스택(Call Stack)이 오버플로해서 프로그램이 강제종료되는 것
  * 대개 재귀 호출의 깊이가 너무 깊어져서 발생
* 대회참여 시 스택 허용량에 대해 알아 둘 필요가 있음

#### 다차원 배열 인덱스 순서 바꿔쓰기

* 2차원 이상 다차원 배열 사용 시 인덱스를 잘못 쓰는 경우가 발생가능
  * 가능한 특정 배열에 접근하는 위치를 하나로 통일하는게 좋음

#### 잘못된 비교 함수 작성

* 연산자 오버로딩 시 잘못된 비교 함수를 작성하면 다른 결과가 반환될 수 있음

#### 최소, 최대 예외 잘못 다루기

* 코드를 짤 때 가장 작은 입력과 가장 큰 입력에 대해 제대로 동작할지 생각해 보면 오류를 잡을 수 있는 경우가 많음

#### 연산자 우선순위 잘못 쓰기

* 연산자 우선순위에 따라 결과가 다를 수 있어 연산자 우선순위를 잘 기억해 두고 헷갈릴 경우 괄호로 감싸 우선순위를 맞춰줘야 함

#### 너무 느린 입출력 방식 선택

* 고수준 입출력 방식을 이용하면 코드는 간단해지지만 이에 따른 속도 저하도 클 수 있음
  * 입출력 양에 따라 입출력 방식을 선택해 주는 것이 좋음

#### 변수 초기화 문제

* 이전 입력에서 사용한 전역 변수 값을 초기화하지 않고 그대로 사용하는 것
  * 새 테스트 케이스를 처리할 때마다 변수들을 적절히 초기화하도록 신경써야 함

### 3.4 디버깅과 테스트

#### 디버깅에 관하여

* 프로그램 작성 후 원하는 결과와 다르면 개발 도구에서 제공하는 디버거로 디버깅을 함
  * 프로그래밍 대회에서는 디버거는 유용성이 제한됨
    * 대회에선 코드가 길지 않기 때문에 눈으로 디버깅하는 쪽이 더 빠른 경우가 많음
    * 재귀 호출이나 중복 반복문을 많이 사용하는 복잡한 코드는 디버거로 디버깅하기에 적당하지 않음
    * ACM-ICPC처럼 여러 명이 한 대의 컴퓨터를 사용하는 대회에선 디버거를 사용하면 다른 사람들이 아무것도 할 수 없음 
* 디버거 없이 버그를 찾아내는 연습을 하는게 좋음
  * 잘 분리된 기능적인 코드를 작성하면 디버거 없이 눈만으로도 검증하기 비교적 쉬움
  * 작은 입력에 대해 제대로 실행되나 확인하기
    * 예제 입력의 크기가 클 경우 실행 과정을 되짚어 가기가 어렵기 때문에 오동작하는 가장 작은 입력을 먼저 찾아내면 디버깅하기 쉬움
  * 단정문(Assertion) 사용하기
    * 단정문이란 주어진 조건이 거짓일 때 오류를 내고 프로그램을 강제 종료시키는 함수 또는 구문
  * 프로그램의 계산 중간 결과를 출력하기
* 위와 같은 과정을 거쳐도 문제를 못 찾으면 디버거를 사용해도 좋음
* 프로그램이 런타임 오류를 내고 종료하는 경우, 언어에서 스택 기록을 출력해주지 못하면 디버거를 사용해 어디서 왜 죽는지 확인할 수 있음

#### 테스트에 관하여

* 답안 작성 후 제출 전 가능한 많은 예제로 테스트 해보는게 좋음
* `스캐폴딩(Scaffolding)`은 다른 코드를 개발할 때 뼈대를 잡기 위해 임시로 사용하는 코드를 뜻함
  * 스캐폴딩 기법을 활용하여 테스트를 자동화하는 코드를 작성해서 테스트 케이스를 많이 테스트해보면 좋음

### 3.5 변수 범위의 이해

#### 산술 오버플로

* 컴퓨터의 모든 변수에는 담을 수 있는 크기 제한이 존재하기 때문에 수학적/논리적으로는 완전히 정당한 알고리즘도 프로그램으로 구현 시 예상과 다르게 동작하는 경우가 있음
  * 이런 흔한 원인은 `산술 오버플로우(Arithmetic Overflow)`, 어떤 식의 계싼 값이 반환되는 자료형의 표현가능한 범위를 벗어나는 경우를 뜻함
* 자주 실수하는 이유 2가지
  * 대부분의 프로그래밍 언어들은 사칙연산 과정에서 오버플로우가 발생해도 경고를 주지 않음(매번 확인하는게 비효율적이기 때문)
  * 프로그램의 정당성을 검증할 때 프로그램 논리의 정확성에만 집중하다 보면 산술 오버플로가 등장할 수 있다는 사실을 잊기 쉬움

#### 너무 큰 결과

* 프로그램이 출력해야 할 결과가 32비트 자료형 범위를 넘어가면 64비트 정수를 사용하거나 큰 정수 구현을 이용해야 함
  * 큰 정수를 다룰 때는 항상 변수의 형태에 주의하는 습관들 들여야 함

#### 너무 큰 중간값

* 프로그램의 출력 값의 범위는 작지만 중간 과정에서 큰 값을 일시적으로 계산하는 경우 산술 오버플로가 문제가 됨

#### 너무 큰 '무한대' 값

* 예외처리를 위한 무한대 값을 선택할 때 서로 더해지거나 곱해지는 경우가 없는지 살펴보고 오버플로가 나지 않을 크기를 선택하는 게 좋음
  * 저자 추천, 예) 987,654,321

#### 오버플로 피해가기

* 오버플로우를 피하는 가장 간단한 방법은 더 큰 자료형을 쓰는 것
  * 64비트 타입으로 캐스팅하는 것도 한 방법
  * 또 다른 방법은 오버 플로가 나지 않도록 연산의 순서를 바꾸는 것

#### 자료형의 프로모션

* 사칙연산이나 대소 비교 등의 이항 여난자들은 두 개의 피연산자를 받음
  * 만약 피연산자의 자료형이 다르거나 자료형의 범위가 너무 작은 경우 컴파일러들은 대개 같은 자료형으로 변환해 계산하는 것을 `프로모션`이라고 함
  * 프로모션은 가끔 알기 어려운 버그를 만듦
* 프로모션 관련 문제들은 대개 부호 있는 정수와 부호 없는 정수형이 섞였을 때 일어남
* java에서는 부호 없는 정수를 언어 차원에서 아예 지원하지 않아 덜 신경써도 됨(개이득)

```c++
// C++
int a = -2
unsigned int b = 0;

// a + b != -2
// a + b == 4,294,967,294 // 강제로 부호 없는 정수로 캐스팅되며 큰 값이 됨
```

### 3.6 실수 자료형의 이해


#### 실수 연산의 어려움

```C++
// [1, n] 범위의 자연수 x에 대해 x * 1.0 / x == 1인 x의 수를 센다
int countObvious(int n) {
  int nSameCnt = 0;
  for (int x = 1; x <= n; x++) {
    double y = 1.0 / x;
    if (y * x == 1.0)
      ++nSameCnt;
  }
  return nSameCnt;
}
countObvious(50); // 50이 아닌 49가 나옴
```

#### 실수와 근사값

* 컴퓨터는 모든 정수를 정확히 표현 가능하지만 메모리가 유한하기 때문에 모든 실수를 다루는건 불가능
  * 현실 세계에서도 근사 값을 사용하듯, 컴퓨터의 모든 실수 변수는 정확도가 제한된 근사 값을 저장함

#### IEEE 754 표준

* `IEEE 754 표준`은 가장 많은 컴퓨터/컴파일러들에서 사용되는 실수 표기 방식
* 가장 큰 특징들

> 1. 이진수로 실수를 표기
> 2. 부동 소수점 (Floating-Point) 기법
> 3. 무한대, 비정규 수(Subnormal Number), NaN(Not a Number: 숫자 아님) 등의 특수한 값이 존재

* 실제 IEEE 754는 실수 연산에 관한 규정, 오버플로와 언더플로의 처리, 반올림에 관한 규정 등을 모두 포함하는 방대한 표준

#### 실수의 이진법 표기

* 실수의 십진법 표기
  * 소수점 바로 아래 자리의 크기는 1/10, 그 다음 자리는 1/100
  * 일반화하면 소수점 밑 i번째 자리의 크기는 1/10<sup>i</sup>
* 실수의 이진법 표기
  * 소수점 밑 i번째 자리의 크기는 1/2<sup>i</sup>
  * 1011.101의 경우
    * 정수부인 1011은 2<sup>3</sup> + 2<sup>1</sup> + 2<sup>0</sup> = 8 + 2 + 1 = 11
    * 소수부 첫 자리의 크기는 1/2, 세 번째 자리의 크기는 1/8, 소수부는 0.625가 되어 이 수의 십진법 표기는 11.625가 됨

#### 부동 소수점 표기

* 소수점 위 몇 자리, 소수점 및 몇 자리를 설정하듯이 32비트 변수로 정수부 16비트, 소수부 16비트 쓰는 식으로 실수 표기가 가능
  * 하지만 정수부에 너무 많은 비트를 사용해 버리면 소수부 정확도가 떨어짐
  * 소수부에 너무 많은 비트를 배정하면 큰 수를 표현할 수 없음
  * 이런 문제를 해결하기 위해 IEEE 754를 포함한 대부분의 실수 표준에서는 소수점을 옮길 수 있게 함
    * 어떤 형태의 숫자건 소수점을 적절히 옮겨, 소수점 위에 한 자리만 남도록 한 뒤, 최상위 비트에서부터 표현할 수 있는 만큼 표시하고 나머지는 반올림 처리
      * 11.625(10) == 1011.101(2), 이때 소수점을 왼쪽으로 세 칸 옮기면 1.011101이 됨
      * 이 수를 맨 앞에서부터 저장 공간이 허락하는 만큼 저장하는 것
      * IEEE 754에서는 1을 제외한 나머지를 저장하는 방식으로 1비트를 절약함
* 실수 변수는 다음 3가지 정보를 저장

> 1. 부호 비트(Sign Bit) : 양수인지 음수인지 여부
> 2. 지수(Exponent) : 소수점을 몇 칸 옮겼는지 여부
> 3. 가수(Mantissa) : 소수점을 옮긴 실수의 최상위 X 비트

* 부호 비트는 1비트라고 치고, 지수, 가수 비가 갖는 비중을 어떻게 조절하느냐에 따라 실수형 표현할 수 있는 숫자의 크기와 정확도가 결정됨
* IEEE 754를 만든 사람들은 실수형에서 지수보다 가수에 훨씬 많은 비트 수를 부여하기로 결정함
  * 지수는 소수점을 움직이는 횟수이기 때문에, 지수가 상대적으로 작더라도 실생활에서 사용하는 거의 모든 숫자들을 표현가능

* 자주 사용되는 실수형의 종류와 구성
  * 각 실수형이 가지는 지수의 범위는 소수점을 옮길 수 있는 개수, 표현할 수 있는 숫자의 범위가 이 값에 의해 결정됨

| 자료형 | 부호 비트 | 지수 비트 | 가수 비트 | 지수 범위 | 유효자릿수(십진수) |
| --- | ---: | ---: | ---: | ---: | ---: | 
| 32비트 실수형 | 1 | 8 | 23 | -2<sup>7</sup> + 2 ~ 2<sup>7</sup> - 1 | 6 |
| 64비트 실수형 | 1 | 11 | 52 | -2<sup>10</sup> + 2 ~ 2<sup>10</sup> - 1 | 15 |
| 80비트 실수형 | 1 | 15 | 64 | -2<sup>14</sup> + 2 ~ 2<sup>14</sup> - 1 | 18 |

* 32비트 실수형은 십진수로 따졌을 때 최대 7자리의 정확도밖에 제공하지 못함
  * 64비트 실수형은 모두 53비트의 가수를 표현할 수 있으므로 (가수의 첫 자리는 항상 1이기 때문) 54비트 이하의 숫자들은 반올림된 후 버려짐, 반올림되는 숫자들은 전체 숫자에 거의 아무런 영향도 미치지 않음
  * 64비트 실수형은 십진수로 따졌을 때 최대 16자리의 정확도를 제공(정확도의 한계)
* 정확도에 큰 의미가 없는 경우를 제외하면 32비트형은 아예 사용하지 말고 64비트 실수형 이상을 쓰기를 추천함
* 이렇게 소수점을 움직이는 실수 표기법을 소수점이 둥둥 떠다닐 수 있다는 의미에서 `부동 소수점(Floating-Point) 표기법`이라 함
  * 소수점이 움직이지 않고 고정되어 있는 실수 표기법은 `고정 소수점(Fixed-Point) 실수 표기법`이라 함

#### 실수 비교하기

* 이진법으로 표현할 수 없는 형태의 실수는 정확한 값이 아니라 근사 값으로 저장되는데, 이 때 생기는 작은 오차가 계산 과정에서 다른 결과를 가져옴
* 두 실수 값이 같은 지를 비교할 때는 항상 어느 정도의 오차를 염두해 두어야 함, 구체적으로는 두 값의 차이가 매우 작은 경우 두 값이 같다고 판단해야 함
* 아래 코드는 a와 b가 같은지 판단하기 위해 두실수의 차의 절대 값이 미리 정해둔 오차 한도보다 작은지를 확인함

```C++
bool absoluteEqual(double a, double b) {
  return fabs(a - b) < 1e-10; // fabs()는 주어진 실수의 절대 값을 구해줌
}
```

* 만약 a와 b의 실수차가 1/10<sup>10</sup> 보다 큰 경우 위에 absoluteEqual 함수는 안전하지 않음

#### 하나, 비교할 실수의 크기들에 비례한 오차 한도를 정한다

* 많은 경우 코드가 다루는 값의 범위를 예측할 수 있음
  * 실제 입력으로 들어올 최대 값과 최소 값을 대략 예측할 수 있고, 크게 차이 나지 않는 경우 하나의 오차 한도 값을 사용가능
* 첫 번째 경우는 같다고 판단해야 할 큰 값 두 개를 비교하는 경우
  * 두 수를 같다고 판정할 수 있으려면, 오차 한도 값이 항상 커야 하는 점으로 근사 오차 한도를 정함
* 두 번째 경우는 다르게 판단해야 하는 작은 값 두 개를 비교하는 경우
  * 두 수의 차보다 오차 한도가 항상 작아야 하는 점으로 근사 오차 한도를 정함
* 비례한 오차 한도를 정하는 방법은 객관적인 기준이 없음
  * 오차 한도를 적절히 선택하는 기술은 많은 경험과 실패가 필요

#### 둘, 상대 오차를 이용한다

* 문제의 입력으로 주어진 자리수를 알 수 없을 때 비교하는 숫자들의 크기에 비례하여 오차를 정하는 방식을 사용해야 함
  * 두 숫자의 크기에 비해 그 차이가 작다면 두 수가 같다고 판정하는 식
    * 오차 허용 범위는 a와 b가 커지면 커질수록 커짐

```
relativeError(a,b) = |a - b| / max(|a|, |b|)
```

```C++
// a와 b의 오차가 더 큰 수의 0.00000001% 이하이면 true를 반환
bool relativeEqual(double a, double b) {
  return fabs(a - b) <= 1e-8 * max(fabs(a), fabs(b));
}
```

* 위 방법도 완벽하진 않음
  * 어떤 수 x가 0이어야 하는데, 계산 과정에 오차가 누적되어 매우 작은 값이 된 경우
  * relativeError(0, x) = x/x = 1이 될 수 있음
* 절대 오차와 상대 오차를 모두 이용한 실수 비교

```C++
// 절대 오차와 상대 오차를 모두 이용해서 두 수가 같은지 판정
bool doubleEqual(double a, double b) {
  double diff = fabs(a - b);
  // 절대 오차가 허용 범위 안일 경우 무조건 true를 반환
  if (diff < 1e-10) return true;
  // 이 외의 경우에는 상대 오차를 사용
  return diff <= 1e-8 * max(fabs(a), fabs(b));
}
```

#### 대소 비교

* 대소 판단할 때도 연산 오차가 발생가능
  * 비교할 때 항상 두 값이 같은 경우, 두 값이 아주 가까운 경우를 먼저 확인하고 처리해야 함

#### 정확한 사칙연산

* IEEE 표준에 의해 실수 변수들은 정확하게 표현할 수 있는 값은 항상 정확하게 저장하도록 구현됨
  * 가수부 안에 들어가는 정수들은 사칙연산이 항상 정확하게 이뤄짐

#### 코드의 수치적 안정성 파악하기

* 수치적으로 안정적(Numerically Stable)인 코드에서는 실수의 정확도 문제를 고려하지 않아도 됨
  * 수치적으로 안정적이라는 말은 프로그램의 실행 과정에서 발생하는 오차가 더 커지지 않는다는 의미
  * 수치적으로 안정적인 프로그램에서는 중간에 작은 연산 오차가 난다고 해도 최종답은 아주 작은 오차만 가짐
* 수치적인 안정성은 알고리즘의 특징에 따라 좌우되고, 이를 판단하는 데는 많은 시행 착오와 경험이 필요

#### 실수 연산 아예 하지 않기

* 실수 연산은 제대로 하기 어렵기 때문에 실수 연산을 아예 하지 않는 것(...)




