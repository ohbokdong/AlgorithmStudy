# 3장 코딩과 디버깅에 관하여

## 3.1 도입: 코딩의 중요성을 관과하지 말라
어떤 문제를 풀 때나 항상 필요한 코딩  
당장 빨리 코드를 작성하기보다 일기 쉬운 코드를 작성하는 것이 중요  
`간결하고 효율적인 프로그램을 작성하는 능력`, `프로그래밍 능력`과 `논리력`은 프로그래밍 대회를 준비해가면서 얻을 수 있는 것들임

---
## 3.2 좋은 코드를 짜기 위한 원칙
> **간결한 코드를 작성하기**
- 짧으면 짧을수록 오타나 단순 버그 우려가 줄어들고, 디버깅이 쉬워짐
- 전역 변수 쓰기: 프로그램의 흐름을 파악하기 어렵긴 하지만, 프로그래밍 대회에서는 각 변수를 읽고 쓰는 부분이 비교적 명확하기 때문에 괜찮음
- C/C++ 매크로를 사용해 간결한 코드를 작성하는 것
  - for문 안에서 변수 잘못 사용하는 거 방지
  - foreach 사용으로 해결도 가능

> **적극적으로 코드 재사용하기**
- 코드 모듈화(함수나 클래스로 분리)
- 코드 간결화는 당장 차이점이 없더라도 하다보면 그 코드에 익숙해짐 => 버그 생겼을 때도 디버깅 시간에 차이를 가져옴
- 입력을 읽어들이는 함수, 입력을 처리하기 쉬운 형태로 바꾸는 함수, 실제 문제를 푸는 함수가 각각 분리되어야 함

> **표준 라이브러리 공부하기**
- 표준 라이브러리는 검증되었으며, 메모리 관리나 정당성 증명에 신경 쓸 필요가 없어서 편하며 다른 팀원이 이해하기도 쉬움
- 언어의 문자열, 동적 배열, 큐, 스택, 리스트, 사전 등의 자료구조, 그리고 정렬 등의 표준적인 알고리즘 구현 사용법을 반드시 잘 알아두기

> **항상 같은 형태로 프로그램을 작성하기**
- 실수의 원인이 될 수 있으며 디버깅 시간으로 연결되므로 자주 작성하는 알고리즘이나 코드 등에 대해서는 한 번 검증된 코드를 작성하고 꾸준히 사용

> **일관적이고 명료한 명명법 사용하기**
- 변수나 함수 선언

> **모든 자료를 정규화해서 저장하기**
- 같은 자료를 두 가지 형태로 저장하지 않기 (ex. 9/6, 3/2)
- 시간은 utc시간과 시간대의 조합
- 문자열은 읽어들이자마자 UTF-16이나 UTF-8로 인코딩으로 변환

> **코드와 데이터를 분리하기**
- 코드의 논리와 상관 없는 데이터는 가능한 한 분리하는 것이 좋음

---
## 3.3 자주 하는 실수
> **산술 오버플로**
- 계산 과정에서 변수의 표현 범위를 벗어나는 값을 사용하는 것

> **배열 범위 밖 원소에 접근**
- C/C++는 해당 인덱스가 배열 범위 밖인지 확인해주지 않음
- 예방방법: 배열 크기를 정할 때 계산을 신중히 해주는 것
- 0을 시작으로 하는 범위를 1을 시작으로 하는 범위로 혼동하는 것

> **일관되지 않은 범위 표현 방식 사용하기**
- 열린구간() / 닫힌구간[]
- 대부분의 프로그래밍 언어에서 n개의 원소를 갖는 배열 a의 첫번쨰 원소는 a[0]이고, 마지막 원소는 a[n-1]
- C++, begin()은 첫 번째 원소, end()는 마지막 원소 다음에 있는 가상의 원소
- JAVA, SortedSet 인터페이스에서 fromElement는 범위에 포함되지만, toElement는 포함되지 않음
- Python, a[4:8]로 배열을 잘라낼 수 있는데 이것은 a[4]부터 a[7]까지임
- 위 방법들의 장점
  - 첫 번째 값과 마지막 값이 같은 구간을 이용하면 텅 빈 구간을 쉽게 표현할 수 있음 `[2, 2)는 2 <= i < 2인 모든 i를 포함하므로 공집합`
  - 두 구간이 연속해 있는지 쉽게 확인 가능 `[a, b)와 [c, d)가 연속해 있는 지 보려면 b=c 혹은 a=d를 확인`
  - 구간의 크기를 쉽게 알 수 있음 `[a, b)라면 b-a`
- 하지만 자연어랑은 다름, 프로그래밍 언어 기준을 따르는 게 좋음

> **Off-by-one 오류**
- 계산의 큰 줄기는 맞지만 하나가 모자라거나 하나가 많아서 틀리는 코드의 오류들 `100미터 담장에 10미터 간격으로 울타리를 세울 때 필요한 기둥의 갯수는 10개가 아니라 11개`
- 반복문에서 < 혹은 > 연산자와 >= 연산자를 혼동하여 원소를 하나 더 적게, 혹은 많이 순회하는 경우나 반 열린 구간과 닫힌 구간을 서로 혼용해 쓴 경우 흔하게 발생

> **컴파일러가 잡아주지 못하는 상수 오타**
- 철자 오류(스펠링, 대문자 등)
- 0000000 일때 0 갯수
- 64비트 정수형에 들어갈 상수를 쓰면서 64비트라고 지정하지 않은 경우

> **스택 오버플로**
- 콜 스택(call stack)이 오버플로해서 프로그램이 강제종료 되는 것

> **다차원 배열 인덱스 순서 바꿔 쓰기**
- 가능한 한 특정 배열에 접근하는 위치를 하나로 통일하는 것이 좋음

> **잘못된 비교 함수 작성**
```
1. a < a는 항상 거짓. 비반사성(irreflexivity)
2. a < b가 참이면 b < a는 거짓. 비대칭성(asymmetry)
3. a < b가 참이고 b < c가 참이면 a < c. 전이성(transitivity)
4. a < b와 b < a가 모두 거짓이면 a와 b는 같은 값으로 간주. a와 b가 같고, b와 c가 같다면 a와 c도 같아야 함. 상등 관계의 전이성(transitivity of equivalence)
```
- 크기 비교, 사전순 비교만을 사용하더라도 충분한 문제에 복잡한 비교 함수를 작성하는 것도 종종하는 실수
- 자바의 표준 라이브러리가 < 연산 대신에 <= 연산을 비교 함수의 모델로 사용함

> **최소, 최대 예외 잘못 다루기**
- 가능한 입력 중 최소 값과 최대 값이 예외가 되는 문제들이 많음

> **연산자 우선순위 잘못 쓰기**
- 연산자의 우선순위를 잘 기억해두거나, 헷갈릴 경우에는 괄호로 적절히 감싸기

> **너무 느린 입출력 방식 선택**
- 어떤 입출력 방식이 지원되고 빠른지 미리 점검

> **변수 초기화 문제**
- 새 테스트 케이스를 처리할 때마다 변수들을 적절히 초기화하도록 신경 써서 코딩하기

