# 3장 코딩과 디버깅에 관하여

## 3.1 도입: 코딩의 중요성을 관과하지 말라
어떤 문제를 풀 때나 항상 필요한 코딩  
당장 빨리 코드를 작성하기보다 일기 쉬운 코드를 작성하는 것이 중요  
`간결하고 효율적인 프로그램을 작성하는 능력`, `프로그래밍 능력`과 `논리력`은 프로그래밍 대회를 준비해가면서 얻을 수 있는 것들임

---
## 3.2 좋은 코드를 짜기 위한 원칙
> **간결한 코드를 작성하기**
- 짧으면 짧을수록 오타나 단순 버그 우려가 줄어들고, 디버깅이 쉬워짐
- 전역 변수 쓰기: 프로그램의 흐름을 파악하기 어렵긴 하지만, 프로그래밍 대회에서는 각 변수를 읽고 쓰는 부분이 비교적 명확하기 때문에 괜찮음
- C/C++ 매크로를 사용해 간결한 코드를 작성하는 것
  - for문 안에서 변수 잘못 사용하는 거 방지
  - foreach 사용으로 해결도 가능

> **적극적으로 코드 재사용하기**
- 코드 모듈화(함수나 클래스로 분리)
- 코드 간결화는 당장 차이점이 없더라도 하다보면 그 코드에 익숙해짐 => 버그 생겼을 때도 디버깅 시간에 차이를 가져옴
- 입력을 읽어들이는 함수, 입력을 처리하기 쉬운 형태로 바꾸는 함수, 실제 문제를 푸는 함수가 각각 분리되어야 함

> **표준 라이브러리 공부하기**
- 표준 라이브러리는 검증되었으며, 메모리 관리나 정당성 증명에 신경 쓸 필요가 없어서 편하며 다른 팀원이 이해하기도 쉬움
- 언어의 문자열, 동적 배열, 큐, 스택, 리스트, 사전 등의 자료구조, 그리고 정렬 등의 표준적인 알고리즘 구현 사용법을 반드시 잘 알아두기

> **항상 같은 형태로 프로그램을 작성하기**
- 실수의 원인이 될 수 있으며 디버깅 시간으로 연결되므로 자주 작성하는 알고리즘이나 코드 등에 대해서는 한 번 검증된 코드를 작성하고 꾸준히 사용

> **일관적이고 명료한 명명법 사용하기**
- 변수나 함수 선언

> **모든 자료를 정규화해서 저장하기**
- 같은 자료를 두 가지 형태로 저장하지 않기 (ex. 9/6, 3/2)
- 시간은 utc시간과 시간대의 조합
- 문자열은 읽어들이자마자 UTF-16이나 UTF-8로 인코딩으로 변환

> **코드와 데이터를 분리하기**
- 코드의 논리와 상관 없는 데이터는 가능한 한 분리하는 것이 좋음

---
## 3.3 자주 하는 실수
> **산술 오버플로**
- 계산 과정에서 변수의 표현 범위를 벗어나는 값을 사용하는 것

> **배열 범위 밖 원소에 접근**
- C/C++는 해당 인덱스가 배열 범위 밖인지 확인해주지 않음
- 예방방법: 배열 크기를 정할 때 계산을 신중히 해주는 것
- 0을 시작으로 하는 범위를 1을 시작으로 하는 범위로 혼동하는 것

> **일관되지 않은 범위 표현 방식 사용하기**
- 열린구간() / 닫힌구간[]
- 대부분의 프로그래밍 언어에서 n개의 원소를 갖는 배열 a의 첫번쨰 원소는 a[0]이고, 마지막 원소는 a[n-1]
- C++, begin()은 첫 번째 원소, end()는 마지막 원소 다음에 있는 가상의 원소
- JAVA, SortedSet 인터페이스에서 fromElement는 범위에 포함되지만, toElement는 포함되지 않음
- Python, a[4:8]로 배열을 잘라낼 수 있는데 이것은 a[4]부터 a[7]까지임
- 위 방법들의 장점
  - 첫 번째 값과 마지막 값이 같은 구간을 이용하면 텅 빈 구간을 쉽게 표현할 수 있음 `[2, 2)는 2 <= i < 2인 모든 i를 포함하므로 공집합`
  - 두 구간이 연속해 있는지 쉽게 확인 가능 `[a, b)와 [c, d)가 연속해 있는 지 보려면 b=c 혹은 a=d를 확인`
  - 구간의 크기를 쉽게 알 수 있음 `[a, b)라면 b-a`
- 하지만 자연어랑은 다름, 프로그래밍 언어 기준을 따르는 게 좋음

> **Off-by-one 오류**
- 계산의 큰 줄기는 맞지만 하나가 모자라거나 하나가 많아서 틀리는 코드의 오류들 `100미터 담장에 10미터 간격으로 울타리를 세울 때 필요한 기둥의 갯수는 10개가 아니라 11개`
- 반복문에서 < 혹은 > 연산자와 >= 연산자를 혼동하여 원소를 하나 더 적게, 혹은 많이 순회하는 경우나 반 열린 구간과 닫힌 구간을 서로 혼용해 쓴 경우 흔하게 발생

> **컴파일러가 잡아주지 못하는 상수 오타**
- 철자 오류(스펠링, 대문자 등)
- 0000000 일때 0 갯수
- 64비트 정수형에 들어갈 상수를 쓰면서 64비트라고 지정하지 않은 경우

> **스택 오버플로**
- 콜 스택(call stack)이 오버플로해서 프로그램이 강제종료 되는 것

> **다차원 배열 인덱스 순서 바꿔 쓰기**
- 가능한 한 특정 배열에 접근하는 위치를 하나로 통일하는 것이 좋음

> **잘못된 비교 함수 작성**
```
1. a < a는 항상 거짓. 비반사성(irreflexivity)
2. a < b가 참이면 b < a는 거짓. 비대칭성(asymmetry)
3. a < b가 참이고 b < c가 참이면 a < c. 전이성(transitivity)
4. a < b와 b < a가 모두 거짓이면 a와 b는 같은 값으로 간주.
  a와 b가 같고, b와 c가 같다면 a와 c도 같아야 함.
  상등 관계의 전이성(transitivity of equivalence)
```
- 크기 비교, 사전순 비교만을 사용하더라도 충분한 문제에 복잡한 비교 함수를 작성하는 것도 종종하는 실수
- 자바의 표준 라이브러리가 < 연산 대신에 <= 연산을 비교 함수의 모델로 사용함

> **최소, 최대 예외 잘못 다루기**
- 가능한 입력 중 최소 값과 최대 값이 예외가 되는 문제들이 많음

> **연산자 우선순위 잘못 쓰기**
- 연산자의 우선순위를 잘 기억해두거나, 헷갈릴 경우에는 괄호로 적절히 감싸기

> **너무 느린 입출력 방식 선택**
- 어떤 입출력 방식이 지원되고 빠른지 미리 점검

> **변수 초기화 문제**
- 새 테스트 케이스를 처리할 때마다 변수들을 적절히 초기화하도록 신경 써서 코딩하기

---
## 3.4 디버깅과 테스팅

> **디버깅**
- 작은 입력에 대해 제대로 실행되나 확인하기
- 단정문(assertion)을 쓴다. 단정문이란 주어진 조건이 거짓일 때 오류를 내고 프로그램을 강제 종료시키는 함수 또는 구문
- 프로그램의 계산 중간 결과를 출력한다.

> **테스트**
- 여러 테스트케이스를 입력해보기
- 스캐폴딩(scaffolding) - 다른 코드를 개발할 때 뼈대를 잡기 위해 임시로 사용하는 코드
- ex) 임의의 작은 입력을 자동으로 생성해 프로그램을 돌려 보고, 그 답안을 검증하는 프로그램을 짜두기

---
## 3.5 변수 범위의 이해
> **산술 오버플로**
- 어떤 식의 계산 값이 반환되는 자료형의 표현 가능한 범위를 벗어나는 경우
1. 사칙연산 과정에서 오버플로가 나더라도 별다른 경고를 하지 않음
2. 정당성을 검증할 때 논리의 정확성에만 집중하다 보면 등장할 때가 있음

> **너무 큰 결과**
- 습관적으로 32비트 정수를 쓰는 경우

> **너무 큰 중간 값**
- 출력 값의 범위는 작지만 중간 과정에서 큰 값을 일시적으로 계산해야 하는 경우

> **너무 큰 '무한 대'값**
- 예를 들어 32비트 부호 있는 정수라면, 처리할 수 있는 가장 큰 값은 2^31-1
- 무한대 값을 선ㄴ택할 때는 이 무한대 값들이 서로 더해지거나 곱해지는 경우가 없는지 살펴보기

> **오버플로 피해가기**
- 오버플로를 고치는 가장 간단한 방법: 더 큰 자료형을 쓰는 것
- 연산의 순서를 바꾸는 것

> **자료형의 프로모션**
- 피연산자의 자료형이 다르거나 자료형의 범위가 너무 작은 경우 컴파일러들은 대게 이들을 같은 자료형으로 변환해서 계산하는데, 이를 프로모션이라고 함
``` 
C+의 경우
1. 한쪽은 정수형이고 한쪽은 실수형: 정수형이 실수형으로 변환
2. 양쪽 다 정수형이거나 양쪽 다 실수형: 보다 넓은 범위를 갖는 자료형으로 변환
3. 양쪽 다 int형보다 작은 정수형: 양쪽 다 int형으로 변환
4. 부호 없는 정수형과 부호 있는 정수형이 섞여 있는 경우: 부호 없는 정수형으로 변환
```
- C#에서는 컨테이너의 크기가 부호 있는 정수로 반환되므로 고려하지 않아도 됨
- 자바에서는 부호 없는 정수를 언어 차원에서 아예 지원하지 않음

---
## 3.6 실수 자료형의 이해
> **실수 연산의 어려움**
- 예상한 값과 1 차이가 나는 경우가 있음

> **실수와 근사값**
- 근사 값으로 연산한 결과는 수학적으로 정확하지 않을 수 있기 때문에 실수는 훨씬 다루기 까다로움

> **IEEE 754표준**
- IEEE754: 가장 많은 컴퓨터/컴파일러들에게 사용되는 실수 표기 방식
```
IEEE754 특징
- 이진수로 실수를 표기
- 부동 소수점(floating-point) 표기법
- 무한대, 비정규 수(subnormal number), NaN(Not a Number: 숫자 아님) 등의 특수한 값이 존재
```

> **실수의 이진법 표기**

> **부동 소수점 표기**
```
실수 변수가 저장하는 3가지 정보
1. 부호 비트(sign bit): 양수인지 음수인지 여부
2. 지수(exponent): 소수점을 몇 칸 옮겼나?
3. 가수(mantissa): 소수점을 옮긴 실수의 최상위 X비트
```
- IEEE754를 만든 사람들은 실수형에서 지수보다 가수에 훨씬 많은 비트 수를 부여하기로 함
- 필요한 수의 크기에 맞춰 소수점 위치를 옮겨서 사용하기 = 부동 소수점 표기 방식 <-> 고정 소수점(fixed point) 실수 표기법

> **실수 비교하기**
1. 비교할 실수의 크기들에 비례한 오차 한도를 정한다.
2. 상대 오차를 이용한다.

> **대소 비교**
- 두 값이 같은 경우, 두 값이 아주 가까운 경우를 먼저 확인하고 처리해주어야 함

> **정확한 사칙연산**
- IEEE 표준에 의해 실수 변수들은, 정확하게 표현할 수 있는 값은 항상 정확하게 저장하도록 구현되어 있음. 따라서 일정 범위와 크기를 갖는 숫자를 다룰 경우에는 사칙 연산이 정확하게 이루어지며, 정수 변수처럼 다룰 수 있음

> **코드의 수치적 안정성(numerically stable) 파악하기**
- 프로그램의 실행 과정에서 발생하는 오차가 더 커지지 않는다는 말
- 수치적인 안정성은 알고리즘의 특징에 따라 좌우되고, 이를 판단하는 데는 많은 시행 착오와 경험이 필요합니다.

---
## 경고
실수의 범위는 광범위함  
실수 연산을 아예 하지 않는 것도 추천
- 곱셈과 나눗셈의 순서를 바꾸기
- 양변 제곱하기
- 실수 좌표를 써야 하는 기하 문제에서 좌표계를 가로 세로로 정수배 늘리기

---
## 3.7 더 읽을거리
클린코드: 변수와 함수의 명명법, 함수의 구성, 그리고 주석을 쓰는 법까지 깨끗하고 잘 구성된 코드의 여러 원칙과 그들의 적용 예를 보여줌




