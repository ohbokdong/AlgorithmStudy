# 19. 큐와 스택 데크
## 19.1. 도입
### 큐(Queue)
- 한쪽 끝에서 자료를 넣고 반대 쪽 끝에서 자료를 꺼냄
- 선입선출(FIFO, First In First Out)   
   
### 스택(Stack)
- 한쪽 끝에서 자료를 넣고 뺌
- 후입선출(LIFO, Last In First Out)

### 데크(Dequeue)
- 양쪽 끝에서 자료들을 넣고 뺌
- 스택과 큐 모두 구현 가능

## 19.2. 큐와 스택, 데크의 구현
### 연결 리스트를 통한 구현
- 양쪽 끝에서의 추가와 삭제를 모두 상수 시간에 할 수 있음
- 노드의 할당과 삭제 그리고 포인터를 따라가는 데 드는 시간이 걸리기 때문에 가장 효율적인 구현은 아님

### 동적 배열을 이용한 구현
- 스택의 경우 한쪽 끝에서만 자료의 추가와 삭제가 일어나므로 동적 배열을 곧장 사용할 수 있지만 큐와 데크의 경우에는 그렇게 간단하지 않음
    - 뒤에서 원소를 추가하거나 삭제하기는 쉽지만 배열의 맨 앞에서 원소를 삭제하기 위해서는 ***O(n)***의 시간이 걸리기 때문
- 동적 배열을 이용해 큐나 데크를 구현 할 때는 첫 번째 원소와 마지막 원소의 위치를 두 변수 `head`와 `tail`에 유지하면서, 맨 앞에서 원소를 꺼낼 때 뒤에 있는 원소들을 모두 앞으로 옮겨오는 대신 head를 다음 원소로 옮김
- 이같은 방식은 모든 연산을 상수 시간에 한다는 목적에 부합하지만 버려지는 공간이 너무 많다는 문제가 있음. 원소를 앞에서 뺄 때 마다 버려지는 공간이 늘어남
    - 이와 같은 문제를 해결하는 좋은 방법은 앞의 버려지는 공간을 재활용하면서, 더이상 원소를 삽입할 곳이 없을 때만 동적 배열을 재할당하는 것
        - 동적 배열의 처음과 끝을 붙여 원형으로 만들었다고 생각할 수 있다는 점에서 이와 같은 배열의 구현을 대개 환형 버퍼(circular buffer)라고 부름

