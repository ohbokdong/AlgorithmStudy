# 19. 큐와 스택 데크
## 19.1. 도입
### 큐(Queue)
- 한쪽 끝에서 자료를 넣고 반대 쪽 끝에서 자료를 꺼냄
- 선입선출(FIFO, First In First Out)   
   
### 스택(Stack)
- 한쪽 끝에서 자료를 넣고 뺌
- 후입선출(LIFO, Last In First Out)

### 데크(Dequeue)
- 양쪽 끝에서 자료들을 넣고 뺌
- 스택과 큐 모두 구현 가능

## 19.2. 큐와 스택, 데크의 구현
### 연결 리스트를 통한 구현
- 양쪽 끝에서의 추가와 삭제를 모두 상수 시간에 할 수 있음
- 노드의 할당과 삭제 그리고 포인터를 따라가는 데 드는 시간이 걸리기 때문에 가장 효율적인 구현은 아님

### 동적 배열을 이용한 구현
- 스택의 경우 한쪽 끝에서만 자료의 추가와 삭제가 일어나므로 동적 배열을 곧장 사용할 수 있지만 큐와 데크의 경우에는 그렇게 간단하지 않음
    - 뒤에서 원소를 추가하거나 삭제하기는 쉽지만 배열의 맨 앞에서 원소를 삭제하기 위해서는 ***O(n)***의 시간이 걸리기 때문
- 동적 배열을 이용해 큐나 데크를 구현 할 때는 첫 번째 원소와 마지막 원소의 위치를 두 변수 `head`와 `tail`에 유지하면서, 맨 앞에서 원소를 꺼낼 때 뒤에 있는 원소들을 모두 앞으로 옮겨오는 대신 head를 다음 원소로 옮김
- 이같은 방식은 모든 연산을 상수 시간에 한다는 목적에 부합하지만 버려지는 공간이 너무 많다는 문제가 있음. 원소를 앞에서 뺄 때 마다 버려지는 공간이 늘어남
    - 이와 같은 문제를 해결하는 좋은 방법은 앞의 버려지는 공간을 재활용하면서, 더이상 원소를 삽입할 곳이 없을 때만 동적 배열을 재할당하는 것
        - 동적 배열의 처음과 끝을 붙여 원형으로 만들었다고 생각할 수 있다는 점에서 이와 같은 배열의 구현을 대개 환형 버퍼(circular buffer)라고 부름

## 19.3 스택과 큐의 활용
### 큐를 이용한 조세푸스 문제의 해법
- 이전 방식 : 반복자가 리스트의 끝에 도달하면 처음으로 옮겨주어 순환하는 방식
- 큐를 활용한 방식 : 죽을 사람을 가리키는 포인터를 k-1번 옮기는 대신 사람들을 k-1번 움직임
   
1. 큐의 첫 번째 사람이 나와서 죽고
2. 큐의 맨 앞에 있는 사람을 맨 뒤로 보내는 작업을 k-1 번 반복

- 연결 리스트를 사용한 것과 동일한 수행 시간을 갖지만 자잘한 구현이 좀 더 간단해짐