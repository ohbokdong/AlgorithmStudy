# **19 큐와 스택, 데크**


## **19.1 도입**

현실 세계의 규칙을 추상화하는 추상화 자료 구조의 대표들로 일렬로 늘어선 자료들을 표현하는 자료 구조.

자료를 넣고 꺼내는 연산을 지원함.



### **큐와 스택, 데크**

**큐(Queue)**  

한쪽 끝에서 자료를 넣고 반대 쪽 끝에서 자료를 꺼낼 수 있음  
이 속성을 선입선출(FIFO:First In First Out)

**스택(Stack)**  

한쪽 끝에서만 자료를 넣고 뺄 수 있음  
가장 늦게 들어간 자료를 가장 먼저 꺼냄 이 속성을 후입선출 (LIFO: Last In First Out)

**스택(Stack)**  

양쪽 끝에서 자료들을 넣고 뺄 수 있는 자료 구조  
데크를 이용하면 스택과 큐를 모두 구현 할 수 있음

## **19.2 큐와 스택, 데크의 구현**

세가지  자료 구조를 구현하는 가장 간단한 방법은 연결 리스트를 사용한 방법  
연결 리스트를 이용하면 양쪽 끝에서의 추가와 삭제를 모두 상수 시간에 할 수 있기 때문에  
모든 연산이 상수 시간이어야 한다는 요구 조건을 쉽게 충족함.

노드의 할당과 삭제, 포인터를 따라가는데 드는  시간때문에 가장 효율적인 구현은 아님

### **동적 배열을 이용한 구현**

스택의 경우 한쪽 끝에서만 자료의 추가와 삭제가 일어나므로 동적 배열을 곧장 사용 할 수 있음

큐와 데크의 경우는 그렇게 간단하지 않음 - 추가, 삭제는 쉬우나 맨 앞에 원소를 삭제기 O(n)의 시간이 걸림

동적 배열을 이용해 큐나 데크를 구현 할 때는 첫 번째와 마지막 원소의 위치를 두 변수 head와 tail에 유지 하면서 맨 앞에서 원소를 꺼낼 때 뒤에 있는 원소들을 모두 앞으로 옮겨오는 대신 head를 다음 원소로 옮김

[그림 19.1 머리와 꼬리를 갖는 큐 참조 - P.627 ]


모든 연산을 상수 시간에 한다는 목적에는 부합. 버려지는 공간이 너무 많다는 문제가 있음

문제를 해결 하는 좋은 방법은 앞의 버려지는 공간을 재활용 더이상 원소를 삽입할 곳이 없을 때만 동적 배열을 재할당 하는것  
어떻게 생각하면 동적 배열의 처음과 끝을 붙여 원형으로 만들었다고 생각 할 수도 있음  
이와 같은 배열의 구현을 대개 환형 버퍼라고 함


### **표준 라이브러리의 구현**

거의 모든 언어의 표준 라이브러리에서 구현체를 제공.

하지만 여러 이유로 자체적인 라이브러리를 만드는 곳도 많음

## **19.3 스택과 큐의 활용**

### **예제: 큐를 이용한 조세푸스 문제의 해법**

18.3 에 나왔던 나쁜놈 조세푸스 문제를 큐를 이용해서 문제를 풀 수 있음

기존에 포인터를 옮겨서 해결했다면 사람을 움직여 두명이 남을때 까지 반복해서 진행  

- 큐의 첫 번째 사람 킬
- 킬 후 다음 사람을 k-1번 뒤로 보냄

기존 연결리스트 방식와 똑같은 상수 시간에 해결, 다만 구현이 좀더 간단

### **예제: 스택을 이용한 울타리 자르기 문제의 해법**

조금 까다롭지만 분할 정복을 이용한 O(NlgN)보다 빠른 O(n)시간에 동작 하기 때문에 확인 해봄

[그림 19.2 i번 판자의 최대 사각형과 왼쪽 끝, 오른쪽 끝 첨조 - P.629]는 다음의 특징이 있음

- 이 사각형의 높이는 i번 판자와 항상 같다.
- 이 사각형의 왼쪽 끝과 오른쪽 끝은 i번째 판자보다 낮은 판자들로 막혀 있다.  
사각형을 막는 판자들의 번호를 각각 left[i], right[i]로 부름

left[i]와 right[i]를 알고 있다면 최대 사각형의 넓이는 간단하게 계산 할 수 있음

(right[i] - left[i] -1) * h[i]

간단하게 left[i]와left[i]를 찾는 간단한 알고리즘은 수행하는데 O(n^2)이 걸림

문제 해결의 키는 각 판자에 대한 문제를 따로 푸는 것이 아니라 다른 판자에 대해 계산했던 정보를 재활용 하는 것

### **스위핑 알고리즘의 설계**
블라블라블라 쏼라쏼라

``` c++
vector<int> h;

int solveStack()
{
    stack<int> remaining;

    h.push_back(0);

    int ret = 0;

    for (int i = 0; i<h.size(); ++i)
    {
        //remaining 안에 아무것도 없는 데 top 하면 에러남
        // 그렇게 코드는 돌아감 단축 평가로 인해 뒤는 실행 x
        while( !remaining.empty() && h[remaining.top()] >= h[i])
        {
            int j = remaining.top();
            remaining.pop();
            int width = -1;
            if(remaining.empty()
            {
                width = i;
            }
            else
            {
                width = (i - remaining.top() - 1);
            }
            ret = max(ret, h[j]*width);
        }
        remaining.push(i);
    }
    return ret;
}

```

## **19.4 문제: 짝이 맞지 않는 괄호**
문제는 책 P.633 참조

- 모든 괄호는 해당하는 짝이 있어야함
- 모든 괄호 쌍은 먼저 열린 뒤 닫힘
- 한 괄호 쌍이 다른 괄호쌍과 서로 교차해 있으면 안됨

## **19.5 풀이: 짝이 맞지 않는 괄호**

스택을 이용해 해결하는 문제

여는 괄호는 스택에 푸쉬 닫는 괄호면 스택 맨위의 괄호와 맞는지 확인, 안맞는 다면 오류 반환


``` c++
bool wellMatched(const string& formula)
{
    const string opening("({["), closing(")}]");//괄호에 대한 정의

    stack<char> openstack; // opening에 대해서 넣을 스택
    for (size_t i = 0; i < formula.size(); i++)
    {
        if (opening.find(formula[i])!= -1) //opening이라면 스택에 추가
        {
            openstack.push(formula[i]);
        }
        else //closing 이면
        {
            // 스택 사이즈 확인
            if (openstack.empty()) return false;
            //opening의 해당 위치가 나옴opening.find('(') 일때 0, closing.find(formula[i]) 가 closing.find(')') 라면 결과는 0
            // 같다면 서로 짝인 상태 아니면 짝이 아니므로 false 리턴
            if (opening.find(openstack.top()) != closing.find(formula[i]))
            {
                return false;
            }
            openstack.pop();
        }
    }
    return openstack.empty();
}
```