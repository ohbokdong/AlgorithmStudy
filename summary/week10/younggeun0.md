## 트리의 구현과 순회

---

**트리는 계층관계를 갖는 객체들을 표현하기 위해 만들어진 자료구조**
* 실제 계층 관계가 없는 자료들을 트리로 표현하면 같은 연산을 더 빠르게 처리할 수 있음


**선형으로 표현하기 어려운 형태의 자료 중 흔한 것으로 계층 구조가 있음**
* 자료 간에 상하위 관계나 포함 관계가 존재하는 경우 계층 구조가 생김
* 계층적 구조를 갖는 자료들을 표현하기 위한 자료구조가 **트리(Tree)**

트리는 처음 현실 세계의 계층구조 개념을 추상화해 표현하는 자료 구조로 고안됐지만 탐색형 자료 구조로도 유용하게 쓰임
* 특정한 조건을 지키도록 구성된 트리들을 이용하면 배열이나 리스트를 사용하는 것보다 같은 작업을 더 빠르게 할 수 있기 때문

### 기초적인 정의와 용어
* **트리의 구성 요소**
  * 노드(Node) - 자료가 저장된 곳
  * 간선(Edge) - 노드들이 연결돼 있는 선
  * 노드 간에는 상/하위 관계가 있으며, 두 노드가 연결되었을 때 한 노드는 좀 더 상위, 다른 노드는 좀 더 하위에 있어야 함
* **노드들의 상대적 관계를 지칭하기 위해 가계도에서 사용하는 용어를 흔히 사용**
  * 부모(Parent) - 두 연결된 노드 중 상위노드
  * 하위 노드를 자식(Childe) 노드라고 함
  * 부모 노드가 같은 두 노드는 형제(Sibling) 노드라고 함
  * 부모 노드와 그의 부모들을 통틀어 선조(Ancestor)라고 함
  * 자식노드와 그 자식들을 통틀어 자손(Descendant)라고 함
* **트리에서 한 노드는 여러 개의 자식을 가질 수 있어도 부모는 하나만 가질 수 있음**
  * 다른 모든 노드들을 자손으로 갖는 노드는 루트(Root) 노드라 함
  * 자식이 하나도 없는 노드들은 트리의 잎 노드 혹은 리프(Leaf)라 함
* **트리와 노드의 속성**
  * 루트에서 어떤 노드에 도달하기 위해 거쳐야 하는 간선의 수를 해당 노드의 깊이(Depth)라 함
    * 깊이가 깊을 수록 트리 아래쪽에 있는 노드를 지칭
  * 트리에서 가장 깊숙히 있는 노드의 깊이를 해당 트리의 높이(Height)라 함
* **트리의 재귀적 속성**
  * 트리가 유용하게 사용되는 큰 이유 중 하나
  * 트리에서 한 노드와 그의 자손들을 모으면 그들도 하나의 트리가 됨
    * 어떤 노드 t와 그 자손들로 구성된 트리를 't를 루트로 하는 서브트리(Subtree)'라고 함
    * 따라서 모든 트리는 루트와 루트 밑에 있는 서브트리의 집합
  * 이와 같은 재귀적 속성 때문에 트리를 다루는 코드들은 대개 재귀 호출을 이용해 구현됨
* **트리의 표현**
  * 트리는 다양한 방법으로 구현할 수 있음
  * 가장 일반적인 형태는 각 노드를 하나의 구조체/객체로 표현하고 이들을 서로 포인터로 연결하는 것

```c++
// code 21.1 트리의 노드를 표현하는 객체의 구현
struct TreeNode {
  string label;                // 저장할 자료(문자열일 필요는 없음)
  TreeNode* arent;            // 부모 노드를 가리키는 포인터
  vector<TreeNode*> children;  // 자손 노드들을 가리키는 포인터의 배열
}
```

* 모든 트리가 이처럼 구현된건 아님, 트리의 구조나 사용 용도가 제한되어 있는 탐색용 트리에서는 효율성을 위해 좀더 단순한 형태의 구현을 자주 사용하게 됨
  * 이진 검색 트리는 왼쪽, 오른쪽에 최대 하나씩만 자식들을 가질 수 있음
    * 자식 노드의 포인터를 담는 대신, 두 포인터(left, right)를 이용해 자식들을 저장함
  * 힙에서는 노드가 들어갈 수 있는 자리가 비어 있는 일이 없이 노드를 꽉꽉 채워넣기 때문에 배열을 사용해 트리의 내용을 표현할 수 있음
  * 상호 배타적 집합 구조에서는 각 노드가 자신의 부모를 가리키는 포인터를 가지고 있을 뿐, 부모는 각 자식에 대한 정보가 없음


### 트리의 순회
* 자료 구조의 가장 기초적인 연산 중 하나는 포함되어 있는 자료를 전부 순회하는 것
  * 선형으로 구성된 배열과 달리 트리는 구조가 일정하지 않기 때문에 포함된 모든 자료들을 순회하기가 쉽지 않음
* 트리의 재귀적 속성을 이용하면 모든 트리는 각 자식들을 루트로 하는 서브트리와 루트로 나눌 수 있음
  * 트리의 루트가 주어질 때 루트를 '방문'한 뒤 각 서브트리를 재귀적으로 방문하는 함수를 만들어 트리의 모든 노드를 순회가능

``` c++
// code 21.2 트리를 순회하며 모든 노드에 포함된 값을 출력하기
// 주어진 트리의 각 노드에 저장된 값을 모두 출력한다
void printLabels(TreeNode* oot) {
  // 루트에 저장된 값을 출력한다.
  cout << root->label << endl;
  // 각 자손들을 루트로 하는 서브트리에 포함된 값들을 재귀적으로 출력한다.
  for (int i=0; i<root->children.size(); i++) {
      printLabels(root->children[i]);
  }
}
```

* **트리의 순회 시간**
  * 트리에 n개의 노드가 있다고 하면 모두 순회하기 위해서는 O(n)이 들어야 정상
  * 실제로 코드 21.2의 경우 for문 내부가 한 번 수행될 때마다 printLabels()가 호출되는데, 이 함수는 트리의 모든 노드에 대해 한 번씩만 호출되므로 for문 내부의 전체 수행 회수는 정확히 n-1번
* 순회의 또 다른 사용 예로 트리의 높이를 구하는 문제가 있음
  * 서브트리의 개념을 이용하면 트리의 높이 또한 재귀적으로 정의가능
    * 루트의 각 자식들을 루트로 하는 서브트리들의 높이를 각각 재귀 호출을 통해 계산함
    * 전체 트리의 높이는 그 중 최대치에 1을 더한 것이 됨
      * 자손이 없는 경우 높이는 0

``` c++
// code 21.3 순회를 이용해 트리의 높이를 계산하기
// root를 루트로 하는 트리의 높이를 구함
int height(TreeNode* oot) {
  int h = 0;
  for (int i=0; i<root->children.size(); i++) {
      h = max(h, 1 + height(root->children[i]));
  }
  return h;
}
```

### 트리의 순회

* 트리는 배열처럼 1차원적인 구조가 아니기 때문에 트리를 순회하는 방법은 한 가지의 순서만 존재하지 않음
  * 때문에 필요에 맞춰 순서를 정의
* 이진트리(Binary Tree)는 모든 노드에 왼쪽과 오른쪽, 최대 두 개의 자손이 있는 트리
  * 이진 트리의 순회 중 유명한 세 가지
    * 트리의 루트를 언제 방문하는지가 서로 다름
  * 전위 순회(Preorder Traverse)
    * 맨 처음에 트리의 루트를 방문, 왼쪽과 오른쪽 서브트리를 순서대로 방문
    * F -> B -> A -> D -> C -> E -> G -> I -> H
  * 중위 순회(Inorder Traverse)
    * 왼쪽 서브트리 먼저 방문, 루트 방문, 오른쪽 서브트리 방문
      * 왼쪽과 서브트리 사이에 트리의 루트를 방문
    * A -> B -> C -> D -> E -> F -> G -> H -> I
  * 후위 순회(Postorder Traverse)
    * 왼쪽 서브트리, 오른쪽 서브트리 먼저 방문 후 루트 방문
    * A -> C -> E -> D -> B -> H -> I -> G -> F

### 트리 순회 순서 변경(문제 ID : TRAVERSAL)

* 어떤 이진 트리를 전위 순회했을 때 노드들의 방문 순서와 중위 순회했을 때 노드들의 방문 순서가 주어졌을 때, 후위 순회했을 때 노드들을 어떤 순서대로 방문하게 될지 계산하는 문제

* 입력
  * 테스트 케이스 수 C (C<=1<=100)
  * 트리에 포함된 노드의 수 N(1<=N<=100)
  * 트리를 전위 순회했을 때, 중위순회 했을 때의 노드 방문 순서가 N개의 정수로 주어짐
  * 각 노드는 1000 이하의 자연수로 번호가 매겨져 있으며 한 트리에 두 노드의 번호가 같은 일은 없음
* 출력
  * 각 테스트 케이스마다 한 줄에 해당 트리의 후위 순회했을 때 노드들의 방문 순서를 출력

```c++
// 예제 입력
1 // C
7 // N
27 16 9 12 54 36 72 // Pre
9 12 16 27 36 54 72 // Inorder

// 예제 출력
12 9 16 36 72 54 27
```

* 전위 순회 결과로 트리의 루트를 구함
  * 루트로 중위 순회 결과에서 왼쪽 서브트리, 오른쪽 서브트리를 찾음

``` c++
// code 21.4 트리 순회 순서 변경 문제를 해결하는 재귀 호출 코드

vector<int> slice(const vector<int>& v, int a, int b) { // 배열을 서브트리 크기로 자르는 함수
  return vector<int>(v.begin() + a, v.begin() + b);
}

// 트리의 전위탐색 결과와 중위탐색 결과가 주어질 때 후위탐색 결과를 출력
voide printPostOrder(const vector<int>& preorder, const vector<int>& indorer) {
  // 트리에 포함된 노드의 수
  const int N = preorder.size();
  // 기저 사례: 텅 빈 트리면 곧장 종료
  if (preorder.empty()) return;
  // 이 트리의 루트는 전위 탐색 결과로부터 곧장 알 수 있음
  const int root = preorder[0];

  // 이 트리의 왼쪽 서브트리의 크기는 중위 탐색 결과에서 루트의 위치를 찾아서 알 수 있음
  const int L = find(inorder.begin(), inorder.end(), root) - inorder.begin();

  // 오른쪽 서브트리의 크기는 N에서 왼쪽 서브트리와 루트를 빼면 알 수 있음
  const int R = N - 1 - L;

  // 왼쪽과 오른쪽 서브트리의 순회 결과를 출력
  printPostOrder(slice(preorder, 1, L+1), slice(inorder, 0, L)); // 왼쪽 서브트리 후위 순회 출력
  printPostOrder(slice(preorder, L+1, N), slice(inorder, L+1, N)); // 오른쪽 서브트리 후위 순회 출력

  // 후위 순회이므로 루트를 가장 마지막에 출력
  cout << root << ' ';
}
```