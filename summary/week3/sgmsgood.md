## 알고리즘의 시간 복잡도 분석

---

## 4.1 도입
### 4.1.1 반복문이 지배한다.
* 알고리즘의 수행 시간을 지배하는 것 = 반복문 

## 4.2 선형시간 (linear time) 알고리즘
* 입력의 크기에 대비해 걸리는 시간을 그래프로 그리면 정확히 직선이 되는 알고리즘
* 우리가 찾을 수 있는 알고리즘 중 가장 좋은 알고리즘인 경우가 많다.
   (주어진 입력을 최소한 한 번씩은 쳐다보기 때문에)

## 4.3 선형 이하 시간 알고리즘 (이진탐색)
* 선형 이하 시간으로 걸리는 알고리즘은 선형시간과는 달리, 모든 입력 자료를 훑어보지 않기 때문에 시간이 빠름
* 이진탐색 (binary search)
  * 사전 or 전화번호부 검색 시에 사용되는 알고리즘
  >> binsearch(A[], x) = 오름차순으로 정렬된 배열 A[]와 찾고 싶은 값 x가 주어질 때 A[i-1]< x < A[i]인 i를 반환한다. 이 때 A[-1] = -∞, A[N] = ∞로 가정한다.


## 4.4 지수 시간 알고리즘
* 다항식 = 변수 N과 N2(N제곱), 그 외 N의 거듭 제곱들의 선형 결합으로 이루어진 식들을 다항식이라고 부릅니다.
* 다항 시간 알고리즘 = 반복문의 수행 횟수를 입력 크기의 다항식으로 표현할 수 있는 알고리즘을 다항 시간 알고리즘으로 부름
* M가지의 항목마다 Yes or No의 선택지가 있으므로 2의 M제곱 가지가 됨.
* 즉, N이 하나 증가할 때마다 걸리는 시간이 배로 증가하는 알고리즘

```c++ 음식메뉴 정하기
const int INF = 987654321;
bool canEverybodyEat (const vector<int>& menu);
int M;

int selectMenu(vector<int>& menu, int food) {
  if(food == M) {
    if(canEverybodyEat(menu)) return menu.size();
    return INF;
  }
  int ret = selectMenu(menu, food+1);
  menu.push_back(food);
  ret = min(ret, selectMenu(menu, food+1));
  menu.pop_back();
  return ret;
}
```

### 4.4.1 소인수 분해의 수행시간
* 입력값의 크기로 수행시간이 달라지는 알고리즘 (입력값의 개수X)
* 입력값의 크기가 커서 반복되는 횟수가 많아질 수록 오랜 시간이 요구됨

  * 의문점 1: 실제 입력 개수가 늘어나는 것도 아닌데 왜 수행시간이 달라지는가
    * 소인수 분해 문제에서는 입력으로 주어지는 숫자가 특정 범위 안에 있다고 가정할 수 없음.
    * 입력값이 커지면 커질 수록 숫자를 저장하는데 필요한 메모리의 공간도 증가.
    * 이 때, 입력이 차지하는 비트의 수에 따라 수행 시간이 증가한다고 생각하면 문제의 답이 될 수 있음.

---
## 4.5 시간 복잡도
1. 입력값 크기에 따라 수행시간이 달라지는 경우
* 알고리즘이 실행되는 동안 수행하는 *<u>기본적인 연산</u>의 수를 입력 크기에 대한 함수로 표현한 것
* 시간 복잡도가 높다 = 입력의 크기가 증가할 때 알고리즘의 수행 시간이 빠르게 증가한다. <br/>
*기본적인 연산 = 더 작게 쪼갤 수 없는 최소 크기의 연산
* 시간 복잡도가 높다 = **입력의 크기**가 증가할 때 알고리즘의 수행시간이 더 빠르게 증가함
  * 즉, 시간 복잡도가 낮다 != 언제나 더 빠르게 동작한다.
  * 입력 크기가 작을 때에는 시간 복잡도가 높은 알고리즘이 더 빠르게 동작할 수 있음

    1. 기본적인 연산
        1. 두 부호 있는 32비트 정수의 사칙연산
        2. 두 실수형 변수의 대소 비교
        3. 한 변수에 다른 변수 대입하기

    2. 기본적인 연산이 아닌 것 (반복문이 있음)
        1. 정수 배열 정렬하기
        2. 두 문자열이 서로 같은지 확인하기
        3. 입력된 수 소인수 분해하기

2.  입력의 종류에 따라 수행시간이 달라지는 경우
    1. 최선의 수행 시간: 찾으려는 원소가 배열의 맨 앞에 있을 때 알고리즘은 한 번 실행되고 종료.<br/>
     (반복문의 수행 횟수 = 1)
    2. 최악의 수행 시간: 배열에 해당 원소가 없을 때 알고리즘은 N번 반복하고 종료<br/>
      (반복문의 수행 횟수 = N)
    3. 평균적인 경우의 수행 시간: 평균적인 경우의 수행 시간을 분석하기 위해서 존재할 수 있는 모든 입력의 등장 확률이 모두 같다고 가정함. <br/>(주어진 배열이 항상 찾는 원소를 포함한다고 가정하면 반환 값의 기대치 = N/2)

    * 가장 많이 사용하는 시간 = 최악의 수행 시간 or 수행 시간의 기대치

### 4.5.1. 점근적 시간 표기: O 표기법(Big-O Notation)<br/>
* 주어진 함수에서 가장 빨리 증가하는 항만을 남긴 채 나머지를 다 버리는 표기법
* 반복문에 의해 시간 복잡도가 결정됨
* 읽을 때는 Order(오더)라고 합니다. <br/>
  예) O(N): 오더 엔
|문제|반복문의 수행 횟수|O표기
|:------:|:------:|:------:|
|이동평균 구하기|N|O(N)
|이진 탐색|lgN|O(lgN)

* 함수의 상한을 나타냄

### 4.5.2 O표기법의 의미
* 대략적으로 함수의 상한을 나타내는데 의미가 있음
* O 표기법은 각 경우의 수행 시간을 간단히 나타내는 표기법일 뿐, 최악의 수행 시간과 관련이 있는 것은 아님

### 4.5.3 시간 복잡도 분석 연습
#### 선택 정렬(selectionSort) 알고리즘 - O(n<sup>2</sup>)
>> 선택 정렬은 모든 i에 대해 A[i..N-1]에서 가장 작은 원소를 찾은 뒤, 이것을 A[i]에 넣는 것을 반복 
* 중첩된 for문의 수행 횟수가 알고리즘 전체의 수행 시간을 지배한다는 것을 쉽게 알 수 있음

#### 삽입 정렬 (insertionSort) 알고리즘 - O(n<sup>2</sup>)
>> 삽입 정렬의 전체 시간 복잡도는 i에 대한 for문에 좌우됨
* 삽입 정렬은 이미 순서화된 파일에 새로운 하나의 레코드를 순서에 맞게 삽입시켜 정렬한다.



### 4.5.4 시간 복잡도의 분할 상환 분석
* 반복문의 개수가 아닌 더 정확한 시간 복잡도를 계산하는 것 (10장 or 18.2절에서 설명)

## 4.6 수행 시간 어림짐작하기
### 4.6.1 주먹구구 법칙
* 프로그래밍 대회의 시간 제한은 알고리즘의 시간 복잡도가 아니라 프로그램의 수행 시간을 기준으로 함.
* 대부분 시간 복잡도와 입력 크기만 알고 있더라도 알고리즘이 시간 안에 동작할 지 대략적으로 짐작 가능
>>입력의 크기를 시간 복잡도에 대입해서 얻은 반복문 수행 횟수에 대해, 1초 당 반복문 수행 횟수가 1억을 넘어가면 시간 제한을 초과할 가능성이 있다.
* 이 법칙을 적용할 때는 충분한 여유를 두는 것이 좋음. 
  * 예측한 수행횟수가 기준의 10% 이하인 경우와 기준의 10배를 넘는 경우에만 적용
* 단, 반복문 수행 횟수의 예측치가 기준에 가까운 O(N2)알고리즘의 경우 시간 복잡도 외에도 다른 요소들을 참조해 시간 안에 수행될지를 판단해야 함
* 고려해야 하는 요소 
  * 시간 복잡도가 프로그램의 실제 수행 속도를 반영하지 못하는 경우:
    * O표기법은 어디까지나 예측 값일 뿐이므로, 실제 프로그램이 수행하는 반복문의 수는 이 계산의 다섯배일 수도 있고, 10분의 1일 수도 있음
  * 반복문의 내부가 복잡한 경우
    * 반복문 내부는 단순하면 단순할 수록 좋음
  * 메모리 사용 패턴이 복잡한 경우
    * CPU는 메모리에 있는 자료에 직접 접근하는 애신 캐시라고 부르는 작고 빠른 메모리로 옮겨온 뒤 처리
    * 메모리에서 캐시로 자료를 가져올 때 인접한 자료들을 가져오기 때문에, 인접한 자료들은 연속해서 사용하는 프로그램은 메모리에서 매번 자료를 가져올 필요 없이 캐시에 이미 저장된 자료를 사용하게 됨.
    * 시간 복잡도에는 영향을 미치지 않지만, 프로그램의 실제 수행 속도는 훨씬 빨라지게 됨
  * 언어와 컴파일러의 차이
    * C++ 컴파일러의 기준으로 따짐
  * 구형 컴퓨터를 사용하는 경우
  
  ## 4.7 계산 복잡도 클래스: P, NP, NP-완비
  ### 4.7.1 문제의 특성 공부하기
  * 알고리즘 문제의 어려움은 우리가 문제를 풀 때의 난이도가 아님
  * 계산 복잡도 이론에서 문제의 난이도는 해당 문제를 해결하는 빠른 알고리즘이 있느냐임</br>
  * 빠른 알고리즘이란 다항 시간 알고리즘이나 그보다 빠른 알고리즘들
  * 다항 시간 알고리즘이 존재하는 문제들의 집합 = P (ex. 정렬문제)
  * P 문제처럼 같은 성질을 갖는 문제들을 모아놓은 집합을 **시간 복잡도 클래스**라고 부름

  ### 4.7.2 난이도의 함정
  * 계산 복잡도에서 말하는 '어려운 문제'
    * 정말 어려운 문제를 잘 골라서 이것을 어려운 문제의 기준으로 삼습니다.
    * 기준 문제만큼 어렵거나 그보다 어려운 문제들, 다시 말해 '기준 이상으로 어려운 문제들'만을 어렵다고 부름
  * 그러나 주어진 문제가 **기준** 이상으로 어렵다는 기준을 잡기가 힘들다는 것이 한계임
  * 두 문제의 난이도를 비교하기 위해 환산(reduction) 이라는 기법을 이용
  
  ### 4.7.3 NP문제, NP 난해 문제
  * NP = 답이 주어졌을 때 이것이 정답인지를 다항 시간 내에 확인할 수 있는 문제
  * 어려운 문제의 기준 = SAT 문제
  * SAT문제 = N개의 불린 값 변수로 구성된 논리식을 참으로 만드는 변수 값 들의 조합을 찾는 문제
  * NP-난해 (NP-Hard): SAT가 모든 NP문제 이상으로 어렵다는 말은 SAT를 다항 시간에 풀 수 있으면 NP 문제들을 전부 다항시간에 풀 수 있다는 것을 의미
  * NP-완비 (NP-Complete): NP-난해 문제이면서 NP 문제들

  ### P = NP ?
  * P = NP 문제는 밀레니엄 7대 수항 난제임
  * NP-난해 문제 중 하나를 다항 시간에 풀 수 있다면, 이 알고리즘을 이용해 NP에 속한 모든 문제를 다항 시간에 풀 수 있음
  * 이 경우 NP에 속한 모든 문제를 다항 시간에 해결할 수 있으므로 P = NP 임을 알 수 있음
  * 역으로 NP문제 중 하나를 골라 P에 포함되어 있지 않음을 증명하면 P != NP 임을 알 수 있음
  * 이 두 가지를 모두 증명에 성공한 사람은 없음

















