# 알고리즘의 시간 복잡도 분석

---

## 4.1. 도입
- 좀 더 빠른 알고리즘을 만들기 위해 가장 먼저 해야 할 일: 알고리즘의 속도를 어떻게 측정할 것인가

### 프로그램 실행 시간이 알고리즘 속도 기준으로 부적합한 이유
1. 프로그램의 수행 시간은 사용한 프로그래밍 언어, 하드웨어, 운영체제, 컴파일러까지 수많은 요소에 의해 바뀔 수 있기 때문
    - 이러한 외적 요인을 전부 통일하더라도 어떤 문자열 구현을 사용했는지, 함수 인자를 어떻게 넘겼는지 등의 사소한 문제에 따라 프로그램의 수행 시간은 달라질 수 있음
2. 프로그램의 실제 수행 시간이 다양한 입력에 대한 실행 시간을 반영하지 못함
    - 알고리즘은 언제나 같은 속도로 동작하는 것이 아니며, 입력의 크기나 특성에 따라 수행 시간이 달라질 수 있음

### 알고리즘의 수행 시간을 어떤 기준으로 측정해야 할까?
## 반복문이 지배한다
- 알고리즘의 수행 시간을 지배하는 것은 반복문임
- 입력에 상관 없이 항상 같은 수행 시간을 갖는 알고리즘도 있지만, 대개는 입력의 크기에 따라 수행 횟수가 정해지는 반복문이 있기 때문

<table>
    <thead>
        <tr><th>항목</th>
            <th>자동차A</th>
            <th>자동차B</th></tr>
    </thead>
    <tbody>
        <tr><th>시동 거는데 걸리는 시간</th>
            <td>3분</td>
            <td>5초</td></tr>
        <tr><th>문 열었다 닫는 데 걸리는 시간</th>
            <td>1분</td>
            <td>0초</td></tr>
        <tr><th>운전석 등받이 조절에 걸리는 시간</th>
            <td>5분</td>
            <td>0초</td></tr>
        <tr><th>앞 유리 닦는 데 걸리는 시간</th>
            <td>4분</td>
            <td>0초</td></tr>
        <tr><th>최대 시속</th>
            <td>200km/h</td>
            <td>40km/h</td></tr>
    </tbody>
</table>

- 짧은 거리를 달릴 때는 자전거가 빠를 수 있는 것 처럼 입력의 크기가 작을 때는 반복외의 다른 부분들이 갖는 비중이 클 수 있음
- 입력의 크기가 커지면 커질수록 반복문이 알고리즘의 수행 시간을 지배하게 됨
- 따라서 대개 우리는 **알고리즘의 수행 시간을 반복문이 수행되는 횟수로 측정**함
    - 이때 반복문의 수행 횟수는 입력의 크기에 대한 함수로 표현함

```C++
// 주어진 배열 A에서 가장 많이 등장하는 숫자를 반환
// 만약 두 가지 이상 있을 경우 아무것이나 반환
int majority1(const vector<int>& A) {
    int N = A.size();
    int majority = -1, majorityCount = 0;
    
    for (int i = 0; i < N; ++i) {        
        
        // A에 등장하는 A[i]의 수를 센다.
        int V = A[i], count = 0;
    
        for(int j = 0; j < N; ++j) {
            ++count;
        }

        // 지금까지 본 최대 빈도보다 많이 출현했다면 답을 갱신
        if (count > majorityCount) {
            majorityCount = count;
            majority = V;
        }

    }

    return majority;
}
```
- 이 알고리즘의 수행 시간은 배열의 크기 `N`에 따라 변함
- N번 수행되는 반복문이 두 개 겹쳐져 있으므로, 반복문의 가장 안쪽은 항상 N<sup>2</sup>번 실행됨
- 따라서 이 알고리즘의 **수행 시간**은 N<sup>2</sup>임

```C++
// A의 각 원소가 0부터 100사이의 값일 경우 가장 많이 등장하는 숫자를 반환
int majority2(const vector<int>& A) {
    int N = A.size();
    vector<int> count(101, 0); // 0으로 초기화된 101개의 원소를 가지는 vector count를 생성
    for(int i = 1; i <= 100; ++i) {
        count[A[i]]++; // count에 주소를 할당하는건가?
    }
    // 지금까지 확인한 숫자 중 빈도수가 제일 큰 것을 majority에 저장
    int majority = 0;
    for(int i = 1; i <= 100; ++i) {
        if(count[i] > count[majority]) {
            majority = i;
        }
    }
    return majority;
}
```
- 이 코드에는 반복문이 두 개가 있음
- 하나는 N번 수행되고, 다른 하나는 100번 수행되므로 전체 반복문의 수행 횟수는 N + 100
- 하지만 N이 커질수록 후자의 반복문은 수행 시간에서 차지하는 비중이 줄어들게 됨
- 따라서 궁극적으로 이 알고리즘의 수행 시간은 `N`이라고 씀

## 4.2 선형 시간 알고리즘
- `이동평균(moving average)`은 **시간에 따라 변화하는 값**들을 관찰할 때 유용하게 사용할 수 있는 **통계적 기준**
    - 주식의 가격, 연간 국내 총생산(GDP), 몸무게 등
- **시간에 따라 관찰된 숫자**들이 주어질 때 `M-이동 평균`은 마지막 `M`개의 **관찰 값의 평균**으로 정의
- 따라서 새 관찰 값이 나오면 `M-이동 평균`은 새 관찰 값을 포함하도록 바뀜

### N개의 측정치가 주어질 때 매달 M달 간의 이동 평균을 계산하는 프로그램
```C++
// 이동 평균 구하기
vector<double> movingAverage1(const vector<double>& A, int M) {
    vector<double> ret;
    int N = A.size();
    for(int i = M-1; i < N; ++i) {
        // A[i]까지의 이동 평균을 구하자.
        double partialSum = 0;
        for(int j = 0; j < M; ++j)
            partialSum += A[i-j];
        ret.push_back(partialSum / M);
    }
    return ret;
}
```
- 각 위치에서 지난 M개 측정치의 합을 구하고, 이를 M으로 나누면 됨
- 이때 이 코드의 수행 시간은 두 개의 for문에 의해 지배됨
- j를 사용하는 반복문은 항상 **M번 실행**되고 i를 사용하는 반복문은 **N - M + 1**번 실행되므로, 
`전체 반복문`은 M x (N-M+1) = N∙M-M<sup>2</sup>+M번 반복됨
- N = 12, M = 3이면 반복 횟수는 30번이 됨

### 중복된 계산 없애기
<table>
    <tr><th>날짜</th><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>...</td><td>M-1</td><td>M</td><td>M+1</td><td>...</td></tr>
    <tr><th>몸무게</th><td>3.5</td><td>3.5</td><td>3.5</td><td>3.6</td><td>3.5</td><td>...</td><td>80.2</td><td>80.1</td><td>80.3</td><td>...</td></tr>
</table>

- 위와 같은 측정치가 있다고 가정했을 때 이동(M) 평균값을 구하기 위해서는 측정치가 M개는 되어야 이동 평균을 계산할 수 있으니, 태어난 이후 `M - 1일의 이동 평균`과 `M일의 이동 평균`에 포함되는 숫자들을 표 위에서 찾아보자
- 실제 이 둘은 0일과 M일의 몸무게를 제외하면 전부 겹친다는 것을 알 수 있음
- 그러면 측정한 몸무게의 합을 일일이 구할 것 없이 M-1일에 구했던 몸무게의 합에서 0일째에 측정한 몸무게를 빼고 M일째에 측정한 몸무게를 더하면 중복된 계산을 없애 공식을 얻을 수 있음

```C++
// 길이가 N인 실수 배열 A가 주어질 때, 각 위치에서 M-이동 평균 값을 구함
vector<double> movingAverage2(const vector<double>& A, int M) {
    vector<double> ret;
    int N = A.size();
    double partialSum = 0;
    for(int i = 0; i < M-1; ++i)
        partialSum += A[i];
    for(int i = 0; i < N; ++i) {
        partialSum += A[i];
        ret.push_back(partialSum / M);
        partialSum -= A[i-M+1];
    }
    return ret;
}
```
- 하나로 묶여있던 두 개의 반복문을 분리하여 프로그램의 반복문 수행 횟수는 `M - 1 + (N - M + 1) = N`이 됨
- 위 코드의 수행 시간은 N에 정비례함. N이 두 배 커지면 실행도 두 배 오래 걸리고, 반으로 줄어들면 수행 시간도 반으로 줄어듦.
- 입력의 크기에 대비해 걸리는 시간을 그래프로 그려보면 정확히 직선이 됨. 이런 알고리즘을 `선형 시간(linear time) 알고리즘`이라고 부름
- 선형 시간에 실행되는 알고리즘은 대개 우리가 찾을 수 있는 알고리즘 중 가장 좋은 알고리즘인 경우가 많음
    - 주어진 입력을 최소한 한 번씩 쳐다보기라도 하려면 선형 시간이 걸릴 수 밖에 없기 때문

## 4.3 선형 이하 시간 알고리즘
- 어떤 문제건 입력된 자료를 모두 한 번 훑어보는 데에는 입력의 크기에 비례하는 시간(선형 시간)이 걸림
- 입력의 크기가 커지는 것보다 수행 시간이 느리게 증가하는 알고리즘들을 선형 이하 시간(sublinear time) 알고리즘이라고 부름
   
### 이진 탐색
#### 성형전 사진 찾기
<table>
    <tr><th>확인한 사진의 수</th><th>0</th><th>1</th><th>2</th><th>⋯</th><th>9</th><th>10</th><th>11</th>
        <th>12</th><th>13</th><th>14</th><th>15</th><th>16</th></tr>
    <tr><td>남은사진</td><td>100,000</td><td>50,000</td><td>25,000</td><td>⋯</td><td>195</td><td>97</td>
        <td>48</td><td>24</td><td>12</td><td>6</td><td>3</td><td>1</td></tr>
</table>

- 위처럼 탐색 시도 횟수가 늘어갈수록 탐색 범위가 절반씩 줄어드는 알고리즘을 이진 탐색(binary search)이라고 부름

#### 이진 탐색의 정의
- binsearch(A\[\], x) = 오름차순으로 정렬된 배열 A\[\]와 찾고 싶은 값 x가 주어질 때 A\[i-1\] < x ≤ A\[i\]인 i를 반환한다.
이때 A\[-1\] = -∞, A\[N\] = ∞로 가정한다.

#### 그래도 선형 시간 아닌가요?
다음과 같은 이유 때문에 이렇게 분석하지 않음
1. A[]를 실제로 계산해서 갖고 있을 필요가 없음. 위 이진 탐색의 정의에서는 편의를 위해 배열을 넘겨받는다고 했지만, 이진 탐색 알고리즘은 배열을 전해 받아도 그중에 몇 개 보지도 않음. 따라서 이들을 미리 계산할 것이 아니라, 가운데 있는 것들에 대해서만 필요할 때 계산(여기서는 사진을 직접 보고 성형 여부를 판단)을 하면 됨
2. 사진을 다운받고 정렬해 두는 과정은 실제로 성형 전 사진을 찾는 작업과는 별개임

#### 구현
- 5.2 절에서 다시 살펴보겠음

## 4.4 지수 시간 알고리즘
### 다항 시간 알고리즘
- 변수 N과 N<sup>2</sup>, 그 외 `N의 거듭제곱들의 선형 결합으로 이루어진 식`들을 `다항식`이라고 부름
- 반복문의 수행 횟수를 입력 크기의 다항식으로 표현할 수 있는 알고리즘들을 다항 시간 알고리즘이라고 부름
    - 다항 시간 알고리즘은 빠르다고 할 수 없음 (N도 다항 시간이지만 N<sup>100</sup>도 다항 시간이기 때문임)

### 알러지가 심한 친구들
- 집들이에 N명의 친구를 초대하려고 함
- 할 줄 아는 M가지의 음식 중 무엇을 대접해야 할까를 고민하는데, 친구들은 각각 알러지 때문에 못 먹는 음식들이 있어서 아무 음식이나 해서는 안 됨
- 각 친구가 먹을 수 있는 음식이 최소한 하나씩은 있으려면 최소 몇 가지의 음식을 해야 할까?

#### 만들 줄 아는 음식의 목록과, 해당 음식을 못 먹는 친구들의 목록
<table>
    <tr><th></th><th>갈비찜</th><th>피자</th><th>잡채</th><th>떡볶이</th><th>탕수육</th><th>닭강정</th></tr>
    <tr><td>페이</td><td>X</td><td>O</td><td>O</td><td>O</td><td>X</td><td>X</td></tr>
    <tr><td>지아</td><td>X</td><td>X</td><td>X</td><td>X</td><td>O</td><td>O</td></tr>
    <tr><td>민</td><td>O</td><td>X</td><td>O</td><td>X</td><td>O</td><td>X</td></tr>
    <tr><td>수지</td><td>O</td><td>O</td><td>X</td><td>X</td><td>X</td><td>O</td></tr>
</table>

#### 모든 답 후보를 평가하기
- 이 문제에서는 여러 개의 답이 있을 수 있음
    - ex) 만들 수 있는 모든 음식을 한꺼번에 다 한다면 모두가 음식을 하나쯤 먹을 수 있음
- 이렇게 여러 개의 답이 있고 그중 가장 좋은 답을 찾는 문제들을 풀 때 가장 간단한 방법은 모든 답을 일일이 고려해 보는 것
- 만들 수 있는 음식의 모든 목록을 만드는 과정은 여러 개의 결정으로 나누면 자연스러움
    - 우선 첫 번째 요리를 만들지 말지 결정하고, 그 다음엔 두 번째 요리를 만들지 말지를 결정하는 식

![모든 답 세어보기](https://github.com/ohbokdong/AlgorithmStudy/blob/main/summary/week3/images/menu.jpeg)   
- 맨 위의 동그라미 안에 쓰인 텅 빈 목록부터 시작해서, 각 음식을 만들지 말지를 선택해 감
- 맨 윗층에서는 갈비찜을 만들지 여부를 결정함
- 다음 층에서는 피자를 만들지 여부를 결정함
- 이렇게 그림의 맨 끝까지 내려가 보면 마지막 층에서는 존재 가능한 모든 목록을 만나게 됨
    - 이제 모든 친구들이 식사할 수 있는 목록들만을 골라 낸 뒤 가장 음식의 수가 적은 목록을 찾으면 됨
- 이런 알고리즘을 구현하는 가장 쉬운 방법은 `재귀 호출`을 이용하는 것임
    - 이때 재귀 함수는 그림에서의 한 상태를 입력받아 이 상태 밑에 달린 모든 후보들을 검사하고 이 중 가장 좋은 답을 반환하는 역할을 함

```C++
const int INF = 987654321;
// 이 메뉴로 모두가 식사할 수 있는지 여부를 반환
bool canEverybodyEat(const vector<sint>& menu);
// 요리할 수 있는 음식의 종류 수
int M;
// food 번째 음식을 만들지 여부를 결정
int selectMenu(vector<int>& menu, int food) {
    // 기저 사례: 모든 음식에 대해 만들지 여부를 결정했을 때
    if(food == M) {
        if(canEverybodyEat(menu)) return menu.size();
        // 아무것도 못 먹는 사람이 있으면 아주 큰 값을 반환한다.
        return INF;
    }
    // 이 음식을 만들지 않는 경우의 답을 계산
    int ret = selectMenu(menu, food+1);
    // 이 음식을 만드는 경우의 답을 계산해서 더 작은 것을 취한다.
    menu.push_back(food);
    ret = min(ret, selectMenu(menu, food+1));
    menu.pop_back();
    return ret;
}
```

### 지수 시간 알고리즘
- 위 프로그램은 모든 답을 한 번씩 다 확인하기 때문에 전체 걸리는 시간은 만들 수 있는 답의 수에 비례하게 됨
- M가지의 음식마다 만든다, 만들지 않는다의 두 선택지가 있으니 우리가 만들 수 있는 답은 모두 2<sup>M</sup>가지 임
- 답을 하나 만들 때마다 canEverybodyEat()을 수행하니 이 알고리즘의 수행시간은 2<sup>M</sup>에 canEverybodyEat()의 수행 시간을 곱한 것이 됨
- canEverybodyEat()을 수행할 때 반복문이 N∙M번 수행된다고 가정하면 전체 수행시간은 N∙M∙2<sup>M</sup>이 됨
- 2<sup>M</sup>과 같은 지수 함수는 알고리즘의 전체 수행 시간에 엄청난 영향을 미침
    - 이와 같이 N이 하나 증가할 때마다 걸리는 시간이 배로 증가하는 알고리즘들은 지수 시간(exponential time)에 동작한다고 말함
    - 지수 시간은 가장 큰 수행 시간 중 하나로, 입력 크기에 따라 다항 시간과는 비교도 안 되게 빠르게 증가함

### 소인수 분해의 수행 시간
- 입력으로 주어지는 숫자의 개수가 아니라 그 크기에 따라 수행 시간이 달라지는 알고리즘들 또한 지수 수행 시간을 가질 수 있음
```C++
// 가장 간단한 형태의 소인수 분해 알고리즘
// 자연수 n의 소인수 분해 결과를 담은 정수 배열을 반환
vector<int> factor(int n) {
    if(n == 1) return vector<int>(1, 1); // n = 1인 경우는 예외로 함
    vector<int> ret;
    for(int div = 2; n > 1; ++div)
        while(n % div == 0) {
            n /= div;
            ret.push_back(div);
        }
    return ret;
}
```
- 위 코드는 자연수 N이 주어질 때 N의 소인수 분해 결과를 반환하는 간단한 알고리즘을 보여줌
- 이 알고리즘은 N이 1이 될 때까지 가능한 한 모든 숫자로 N을 나눠 봄. 따라서 N의 크기에 따라 반복문의 수행 횟수가 달라지게 됨
- 이 코드에서 반복문이 가장 많이 실행되는 경우는 주어진 수 N이 소수인 경우임
- N이 아무리 커져도 실제 입력은 1개일 뿐인데 수행 시간이 달라진다는 것은 우리의 직관에 맞지 않음

## 4.5 시간 복잡도
- `시간 복잡도(time complexity)`란 가장 널리 사용되는 **알고리즘의 수행 시간 기준**으로, **알고리즘이 실행되는 동안 수행하는 기본적인 연산의 수를 입력의 크기에 대한 함수료 표현**한 것
    - 기본적인 연산이란 더 작게 쪼갤 수 없는 최소 크기의 연산이라고 보면 됨
    - 기본적인 연산의 예
        - 두 부호 있는 32비트 정수의 사칙연산
        - 두 실수형 변수의 대소 비교
        - 한 변수에 다른 변수 대입하기
    - 기본적인 연산이 아닌 것
        - 정수 배열 정렬하기
        - 두 문자열이 서로 같은지 확인하기
        - 입력된 수 소인수 분해하기
- 시간 복잡도가 높다는 말은 입력의 크기가 증가할 때 알고리즘의 수행 시간이 더 빠르게 증가한다는 의미
    - 시간 복잡도가 낮다고 해서 언제나 더 빠르게 동작하는 것은 아님, 입력의 크기가 충분히 작을 때는 시간 복잡도가 높은 알고리즘이 더 빠르게 동작할 수도 있음
    - 시간 복잡도가 낮은 알고리즘은 입력이 커지면 커질수록 더 효율적이게 됨

