## 동적 계획법(Dynamic Programming)

---

### 8.1 도입

#### 동적 프로그래밍 == 동적 계획법

#### 중복되는 부분 문제

* 큰 의미에서 분할 정복과 같은 접근 방식을 의미
  * 처음 주어진 문제를 더 작은 문제로 나눈 뒤 각 조각의 답을 계산하고, 이 답들로부터 원래 문제에 대한 답을 계산
* 동적 계획법에서는 여러번 계산되는 **어떤 부분 문제를 한 번만 계산하고 계산 결과를 재활용함**으로써 속도 향상을 꾀할 수 있음
  * 이미 계산한 값을 저장해 두는 메모리의 장소 - `캐시(Cache)`
  * 두 번 이상 계산되는 부분 문제 - **중복되는 부분 문제(Overlapping Subproblems)**
    * 나눠진 각 문제들이 같은 부분 문제에 의존하는 경우 발생
      * 계산의 중복횟수는 분할의 깊이가 깊어질 수록 지수적으로 증가
    * 문제 분할에 따라 등장하는 중복되는 부분 문제 - p180, 그림 7.2, p208 그림 8.1 참고
        
**동적 계획법 알고리즘 예 - 이항계수(Binomial Coefficient)**
  * 이항 계수 nCr 은 n개의 서로 다른 원소 중에서 r개의 원소를 순서없이 골라내는 방법의 수
  * 이항 계수는 아래와 같은 점화식(Recurrence)이 성립
    * 점화식이란 재귀적으로 정의되는 수학적 함수

![img1](https://github.com/ohbokdong/AlgorithmStudy/blob/main/summary/week6/img/img1.png?raw=true)

```c++
// code 8.1 재귀 호출을 이용한 이항 계수 계산

int bino(int n, int r) {
  // base case, n=r (모든 원소를 다 고른 경우) 혹은 r=0 (고를 원소가 없는 경우)
  // bino() 내에서는 반복문이 없기 때문에 재귀 호출이 몇 번 이뤄지는지 계산하면 수행 시간을 파악가능
  if (r == 0 || n == r) return 1;
  return bino(n-1, r-1) + bino(n-1, r);
}
```

* `bino(n, n/2)`에서 n이 하나 증가할 때마다 함수 호출의 수가 거의 두 배 증가
  * 입력 n과 r이 정해져 있을 때 bino(n, r)의 반환 값이 일정하다는 사실을 이용하면 중복 계산을 제거 가능
  * **함수의 결과를 저장하는 장소를 마련해 두고, 한 번 계산한 값을 저장해 뒀다 재활용하는 최적화 기법을 `메모이제이션(Memoization)`이라고 함**

```c++
// code 8.2 메모이제이션을 이용한 이항 계수 계산

// -1로 초기화
int cache[30][30];
int bino2(int n, int r) {
  if (r == 0 || n == r) return 1;   // base case

  // -1이 아니면 한 번 계산했던 값이므로 리턴
  if (cache[n][r] != -1)
    return cache[n][r];

  // 직접 계산한 뒤 배열에 저장
  return cache[n][r] = bino2(n-1, r-1) + bino2(n-1, r);
}
```

* 메모이제이션을 사용하면 모든 부분 문제가 한 번씩만 계산된다고 보장하여 함수 호출 횟수가 엄청나게 감소함
  * **이와 같이 두 번 이상 계산되는 부분 문제들의 답을 미리 저장함으로써 속도의 향상을 꾀하는 알고리즘 설계 기법을 동적계획법이라 함**



#### 메모이제이션을 적용할 수 있는 경우

* 