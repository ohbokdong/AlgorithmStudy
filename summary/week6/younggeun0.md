## 동적 계획법(Dynamic Programming)

---

### 8.1 도입

#### 동적 프로그래밍 == 동적 계획법

#### 중복되는 부분 문제

* 큰 의미에서 분할 정복과 같은 접근 방식을 의미
  * **처음 주어진 문제를 더 작은 문제로 나눈 뒤 각 조각의 답을 계산하고, 이 답들로부터 원래 문제에 대한 답을 계산**
* **동적 계획법**에서는 여러번 계산되는 **어떤 부분 문제를 한 번만 계산하고 계산 결과를 재활용함**으로써 속도 향상을 꾀할 수 있음
  * 이미 계산한 값을 저장해 두는 메모리의 장소 - `캐시(Cache)`
  * 두 번 이상 계산되는 부분 문제 - **중복되는 부분 문제(Overlapping Subproblems)**
    * 나눠진 각 문제들이 같은 부분 문제에 의존하는 경우 발생
      * 계산의 중복횟수는 분할의 깊이가 깊어질 수록 지수적으로 증가
    * 문제 분할에 따라 등장하는 중복되는 부분 문제 - p180, 그림 7.2, p208 그림 8.1 참고
        
**동적 계획법 알고리즘 예 - 이항계수(Binomial Coefficient)**
  * 이항 계수 nCr 은 n개의 서로 다른 원소 중에서 r개의 원소를 순서없이 골라내는 방법의 수
  * 이항 계수는 아래와 같은 점화식(Recurrence)이 성립
    * 점화식이란 재귀적으로 정의되는 수학적 함수

![img1](https://github.com/ohbokdong/AlgorithmStudy/blob/main/summary/week6/img/img1.png?raw=true)

```c++
// code 8.1 재귀 호출을 이용한 이항 계수 계산

int bino(int n, int r) {
  // base case, n=r (모든 원소를 다 고른 경우) 혹은 r=0 (고를 원소가 없는 경우)
  // bino() 내에서는 반복문이 없기 때문에 재귀 호출이 몇 번 이뤄지는지 계산하면 수행 시간을 파악가능
  if (r == 0 || n == r) return 1;
  return bino(n-1, r-1) + bino(n-1, r);
}
```

* `bino(n, n/2)`에서 n이 하나 증가할 때마다 함수 호출의 수가 거의 두 배 증가
  * 입력 n과 r이 정해져 있을 때 bino(n, r)의 반환 값이 일정하다는 사실을 이용하면 중복 계산을 제거 가능
  * **함수의 결과를 저장하는 장소를 마련해 두고, 한 번 계산한 값을 저장해 뒀다 재활용하는 최적화 기법을 `메모이제이션(Memoization)`이라고 함**

```c++
// code 8.2 메모이제이션을 이용한 이항 계수 계산

// -1로 초기화
int cache[30][30];
int bino2(int n, int r) {
  if (r == 0 || n == r) return 1;   // base case

  // -1이 아니면 한 번 계산했던 값이므로 리턴
  if (cache[n][r] != -1)
    return cache[n][r];

  // 직접 계산한 뒤 배열에 저장
  return cache[n][r] = bino2(n-1, r-1) + bino2(n-1, r);
}
```

* 메모이제이션을 사용하면 모든 부분 문제가 한 번씩만 계산된다고 보장하여 함수 호출 횟수가 엄청나게 감소함
  * **이와 같이 두 번 이상 계산되는 부분 문제들의 답을 미리 저장함으로써 속도의 향상을 꾀하는 알고리즘 설계 기법을 동적계획법이라 함**



#### 메모이제이션을 적용할 수 있는 경우

* `참조적 투명 함수(Referential Transparent Function)`의 경우에만 적용 가능
   *  참조적 투명성(Referential Transparency) - 함수의 반환 값이 그 입력 값만으로 결정되는 여부
   *  프로그래밍은 수학의 함수와 다르게 여러 입력에 의해 출력이 바뀔 수 있음(ex 전역 변수, 입력 파일, 클래스 멤버 변수 등)

#### 메모이제이션 구현 패턴

* 메모이제이션은 동적 계획법으로 자주 구현되므로 항상 한 가지 패턴으로 구현하면 작성, 디버깅이 수월함
* **메모이제이션 구현 패턴**
  * 항상 기저 사례를 제일 먼저 처리한다
  * 캐시는 반환 값과 다른 값으로 초기화 한다
    * 캐시는 참조형(Reference)라는 점에 유의한다
  * 다중 for문을 사용하는 방법이 아닌 메모이제이션용 배열 초기화하는 방법을 알아두면 좋음
* **자신이 가장 좋다고 생각하는 방식을 하나 정해 일관되게 사용하는게 좋음**

```c++
// 코드 8.3 예제
// a, b는 각각 [0, 2500) 구간 안의 정수
// 반환 값은 항상 int 형 안에 들어가는 음이 아닌 정수
// - someObscureFunction은 한 번 처리하는 데 굉장히 시간이 오래 걸리는 참조적 투명 함수라 가정
int someObscureFunction(int a, int b);


// 위 함수를 메모이제이션으로 바꿔 구현한 예
int cache[2500][2500]; // 전부 -1로 초기화
int someObscureFunction(int a, int b) {
  // 기저 사례를 처음에 처리
  if (...) return ...;

  // (a,b)에 대한 답을 구한 적이 있으면 곧장 반환
  int& ret = cache[a][b];
  if (ret != -1) return ret;

  // 여기에서 답을 계산
  ...
  return ret;
}

int main() {
  // memset()을 이용해 cache배열을 초기화
  memset(cache, -1, sizeof(cache));
}
```

#### 메모이제이션 시간 복잡도 분석

* 메모이제이션을 사용하는 알고리즘의 시간 복잡도는 주먹구구로 상한 계산 가능

```
(존재하는 부분 문제의 수) * (한 부분 문제를 풀 때 필요한 반복문의 수행 횟수)
```

#### 예제 : 외발 뛰기 p215

* 목적
  * n * n 격자로 이루어진 게임판에서 왼쪽 위칸에서 시작해 게임판 맨 오른쪽 아래 칸에 도착하는 것
* 문제
  * 게임판이 주어질 때 시작점에서 끝점에 도달하는 방법이 존재하는지를 확인하는 것
* 아래 또는 오른쪽으로 이동이 가능, 다음과 같이 재귀적 표현 가능
  * jump(y,x) = jump(y + jumpSize, x) || jump(y, x + jumpSize)

```c++
// 메모이제이션 전, code 8.4 외발뛰기 문제를 해결하는 재귀 호출 알고리즘
int n, board[100][100];
bool jump(int y, int x) {
  // base case1, 게임판 밖을 벗어난 경우
  if (y >= n || x >= n) return false;

  // base case2, 마지막 칸에 도착한 경우
  if (y == n-1 && x == n-1) return true;

  int jumpSize = board[y][x];
  return jump(y + jumpSize, x) || jump(y, x + jumpSize);
}

// 완전 탐색이 포기하기 전까지 만들어야 하는 경로의 개수는 n에 대해 지수적으로 늘어남
// 비둘기 집의 원리로 중복으로 해결되는 부분문제들이 항상 존재함
// jump()는 참조적 투명 함수, 메모이제이션을 이용해 중복된 연산제거 가능

// 메모이제이션 적용 후
int n, board[100][100];
int cache[100][100]; // -1로 초기화, 계산된 상태(1), 도착할 수 없으면(0)
int jump2(int y, int X) { // 반환형이 int
  if (y >= n || x >= n) return 0;
  if (y == n-1 && x == n-1) return 1;

  // 메모이제이션
  int& ret = cache[y][x];
  if (ret != -1) return ret;

  int jumpSize = board[y][x];
  return ret = jump2(y + jumpSize, x) || jump2(y, x + jumpSize); // 1 || 0 == 1, 1이 반환되면 도달가능
}
```

#### 동적 계획법 레시피

* 대개 동적 계획법 알고리즘은 아래 두 단계로 이루어짐

1. **주어진 문제를 완전 탐색을 이용해 해결**
2. **중복된 부분 문제를 한 번만 계산하도록 메모이제이션 적용**

* 재귀 호출을 이용하지 않고도 동적 계획법 알고리즘을 구현가능 == 반복적 동적 계획법

### 8.2 문제: 와일드카드 p218

* `와일드카드`는 다양한 운영체제에서 파일 이름의 일부만으로 파일 이름을 지정하는 방법
  * 이 때 사용하는 문자열을 와일드카드 패턴이라고 함
  * 패턴은 특수 문자 `*`나 `?`를 포함할 수 있는 문자열
* 이 문제에서 `?`는 어떤 글자와도 대응되고, `*`은 0글자 이상의 어떤 문자열에도 대응됨
* 와일드 카드 패턴과 함께 파일명의 집합이 주어질 때, 패턴에 대응되는 파일명을 찾는 문제
  * `*`가 몇 글자에 대응되어야 하는지 모름 -> 완전 탐색

```c++
// code 8.6 와일드카드 문제를 해결하는 완전 탐색 알고리즘

// 와일드카드 패턴 w가 문자열 s에 대응되는지 여부를 반환함
bool match(const string&w, const string& s) {
  // w[pos]와 s[pos]를 맞춰 나감
  int pos = 0;

  // 대응 종료되는 경우를 찾기 위해 pos++
  // - 1. w[pos] != s[pos]
  // - 2. w가 끝에 도달 시 - *이 없는 경우
  // - 3. s가 끝에 도달 시 - 패턴은 남았지만 문자열이 끝난 경우
  // - 4. w[pos]가 *인 경우
  while (pos < s.size() && pos < w.size() &&
      (w[pos] == '?' || w[pos] == s[pos]))
    ++pos;

  // 더 이상 대응할 수 없으면 왜 while문이 끝났는지 확인

  // 2. 패턴 끝에 도달해서 끝난 경우: 문자열도 끝났어야 대응됨
  if (pos == w.size()) {
    return pos == s.size();
  }

  // 4. *를 만나서 끝난 경우 : *에 몇 글자를 대응해야 할지 재귀 호출하면서 확인
  if (w[pos] == '*')
    for (int skip = 0; pos+skip <= s.size(); ++skip)
      if (match(w.substr(pos+1), s.substr(pos+skip)))
        return true;
  
  // 이 외의 경우에는 모두 대응되지 않음
  return false;
}
```

#### 중복되는 문제

* 재귀호출 시 항상 w, s 앞에서만 글자를 떼어내기 때문에 w와 s는 항상 입력에 주어진 패턴 W와 파일명 S의 접미사가 됨(suffix)
* 메모이제이션 사용해 중복제거

```c++
// code 8.7
// -1 == 계산 전
// 1 == 대응됨
// 0 == 대응되지 않음
int cache[101][101];

string W, S //패턴과 문자열
// 와일드카드 패턴 W[w..]가 문자열 S[s..]에 대응되는지 여부를 반환
bool matchMemoized(int w, int s) {
  // 메모이제이션
  int& ret = cache[w][s];
  if (ret != -1) return ret;

  // W[w] 와 S[s]를 맞춰 나감
  while(s < S.size() && w < W.size() &&
    (W[w] == '?' || W[w] == S[s])) {
      ++w;
      ++s;
  }

  // 더 이상 대응할 수 없으면 왜 while문이 끝났는지 확인
  // 2. 패턴 끝에 도달해 끝난 경우, 문자열도 끝났어야 함
  if (w == W.size()) return ret = (s == S.size());

  // 4. *를 만나서 끝난 경우, *에 몇 글자를 대응해야 할지 재귀호출하면서 확인
  if (W[w] == '*') 
    for (int skip = 0; skip+s <= S.size(); ++skip) 
      if (matchMemoized(w+1, s+skip))
        return ret = 1;
  
  // 3. 이 외의 경우에는 모두 대응되지 않음
  return ret = 0;
}
```

* 패턴과 문자열의 길이가 모두 n일 때 부분 문제의 개수는 n<sup>2</sup>, matchMemoized()는 한 번 호출될 때마다 최대 n번의 재귀 호출을 하기 때문에 시간 복잡도는 O(n<sup>3</sup>)

#### 다른 분해 방법

* 좀 더 똑똑한 분해 방식을 쓰면 O(n<sup>2</sup>)가 가능
  * O(n<sup>3</sup>)가 걸리는 이유는 내부에서 첫 *를 찾고 *에 몇 글자가 대응되어야 할지 검사하는 반복문이 존재하기 때문
    * 재귀 함수 자체에 반복문이 하나도 없도록 리펙토링하면 부분 문제 개수와 같은 시간만을 사용해 문제를 풀 수 있음
  * 