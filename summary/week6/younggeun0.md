## 동적 계획법(Dynamic Programming)

---

### 8.1 도입

#### 동적 프로그래밍 == 동적 계획법

#### 중복되는 부분 문제

* 큰 의미에서 분할 정복과 같은 접근 방식을 의미
  * **처음 주어진 문제를 더 작은 문제로 나눈 뒤 각 조각의 답을 계산하고, 이 답들로부터 원래 문제에 대한 답을 계산**
* **동적 계획법**에서는 여러번 계산되는 **어떤 부분 문제를 한 번만 계산하고 계산 결과를 재활용함**으로써 속도 향상을 꾀할 수 있음
  * 이미 계산한 값을 저장해 두는 메모리의 장소 - `캐시(Cache)`
  * 두 번 이상 계산되는 부분 문제 - **중복되는 부분 문제(Overlapping Subproblems)**
    * 나눠진 각 문제들이 같은 부분 문제에 의존하는 경우 발생
      * 계산의 중복횟수는 분할의 깊이가 깊어질 수록 지수적으로 증가
    * 문제 분할에 따라 등장하는 중복되는 부분 문제 - p180, 그림 7.2, p208 그림 8.1 참고
        
**동적 계획법 알고리즘 예 - 이항계수(Binomial Coefficient)**
  * 이항 계수 nCr 은 n개의 서로 다른 원소 중에서 r개의 원소를 순서없이 골라내는 방법의 수
  * 이항 계수는 아래와 같은 점화식(Recurrence)이 성립
    * 점화식이란 재귀적으로 정의되는 수학적 함수

![img1](https://github.com/ohbokdong/AlgorithmStudy/blob/main/summary/week6/img/img1.png?raw=true)

```c++
// code 8.1 재귀 호출을 이용한 이항 계수 계산

int bino(int n, int r) {
  // base case, n=r (모든 원소를 다 고른 경우) 혹은 r=0 (고를 원소가 없는 경우)
  // bino() 내에서는 반복문이 없기 때문에 재귀 호출이 몇 번 이뤄지는지 계산하면 수행 시간을 파악가능
  if (r == 0 || n == r) return 1;
  return bino(n-1, r-1) + bino(n-1, r);
}
```

* `bino(n, n/2)`에서 n이 하나 증가할 때마다 함수 호출의 수가 거의 두 배 증가
  * 입력 n과 r이 정해져 있을 때 bino(n, r)의 반환 값이 일정하다는 사실을 이용하면 중복 계산을 제거 가능
  * **함수의 결과를 저장하는 장소를 마련해 두고, 한 번 계산한 값을 저장해 뒀다 재활용하는 최적화 기법을 `메모이제이션(Memoization)`이라고 함**

```c++
// code 8.2 메모이제이션을 이용한 이항 계수 계산

// -1로 초기화
int cache[30][30];
int bino2(int n, int r) {
  if (r == 0 || n == r) return 1;   // base case

  // -1이 아니면 한 번 계산했던 값이므로 리턴
  if (cache[n][r] != -1)
    return cache[n][r];

  // 직접 계산한 뒤 배열에 저장
  return cache[n][r] = bino2(n-1, r-1) + bino2(n-1, r);
}
```

* 메모이제이션을 사용하면 모든 부분 문제가 한 번씩만 계산된다고 보장하여 함수 호출 횟수가 엄청나게 감소함
  * **이와 같이 두 번 이상 계산되는 부분 문제들의 답을 미리 저장함으로써 속도의 향상을 꾀하는 알고리즘 설계 기법을 동적계획법이라 함**



#### 메모이제이션을 적용할 수 있는 경우

* `참조적 투명 함수(Referential Transparent Function)`의 경우에만 적용 가능
   *  참조적 투명성(Referential Transparency) - 함수의 반환 값이 그 입력 값만으로 결정되는 여부
   *  프로그래밍은 수학의 함수와 다르게 여러 입력에 의해 출력이 바뀔 수 있음(ex 전역 변수, 입력 파일, 클래스 멤버 변수 등)

#### 메모이제이션 구현 패턴

* 메모이제이션은 동적 계획법으로 자주 구현되므로 항상 한 가지 패턴으로 구현하면 작성, 디버깅이 수월함
* **메모이제이션 구현 패턴**
  * 항상 기저 사례를 제일 먼저 처리한다
  * 캐시는 반환 값과 다른 값으로 초기화 한다
    * 캐시는 참조형(Reference)라는 점에 유의한다
  * 다중 for문을 사용하는 방법이 아닌 메모이제이션용 배열 초기화하는 방법을 알아두면 좋음
* **자신이 가장 좋다고 생각하는 방식을 하나 정해 일관되게 사용하는게 좋음**

```c++
// 코드 8.3 예제
// a, b는 각각 [0, 2500) 구간 안의 정수
// 반환 값은 항상 int 형 안에 들어가는 음이 아닌 정수
// - someObscureFunction은 한 번 처리하는 데 굉장히 시간이 오래 걸리는 참조적 투명 함수라 가정
int someObscureFunction(int a, int b);


// 위 함수를 메모이제이션으로 바꿔 구현한 예
int cache[2500][2500]; // 전부 -1로 초기화
int someObscureFunction(int a, int b) {
  // 기저 사례를 처음에 처리
  if (...) return ...;

  // (a,b)에 대한 답을 구한 적이 있으면 곧장 반환
  int& ret = cache[a][b];
  if (ret != -1) return ret;

  // 여기에서 답을 계산
  ...
  return ret;
}

int main() {
  // memset()을 이용해 cache배열을 초기화
  memset(cache, -1, sizeof(cache));
}
```

#### 메모이제이션 시간 복잡도 분석

* 메모이제이션을 사용하는 알고리즘의 시간 복잡도는 주먹구구로 상한 계산 가능

```
(존재하는 부분 문제의 수) * (한 부분 문제를 풀 때 필요한 반복문의 수행 횟수)
```

#### 예제 : 외발 뛰기 p215

* 목적
  * n * n 격자로 이루어진 게임판에서 왼쪽 위칸에서 시작해 게임판 맨 오른쪽 아래 칸에 도착하는 것
* 문제
  * 게임판이 주어질 때 시작점에서 끝점에 도달하는 방법이 존재하는지를 확인하는 것
* 아래 또는 오른쪽으로 이동이 가능, 다음과 같이 재귀적 표현 가능
  * jump(y,x) = jump(y + jumpSize, x) || jump(y, x + jumpSize)

```c++
// 메모이제이션 전, code 8.4 외발뛰기 문제를 해결하는 재귀 호출 알고리즘
int n, board[100][100];
bool jump(int y, int x) {
  // base case1, 게임판 밖을 벗어난 경우
  if (y >= n || x >= n) return false;

  // base case2, 마지막 칸에 도착한 경우
  if (y == n-1 && x == n-1) return true;

  int jumpSize = board[y][x];
  return jump(y + jumpSize, x) || jump(y, x + jumpSize);
}

// 완전 탐색이 포기하기 전까지 만들어야 하는 경로의 개수는 n에 대해 지수적으로 늘어남
// 비둘기 집의 원리로 중복으로 해결되는 부분문제들이 항상 존재함
// jump()는 참조적 투명 함수, 메모이제이션을 이용해 중복된 연산제거 가능

// 메모이제이션 적용 후
int n, board[100][100];
int cache[100][100]; // -1로 초기화, 계산된 상태(1), 도착할 수 없으면(0)
int jump2(int y, int X) { // 반환형이 int
  if (y >= n || x >= n) return 0;
  if (y == n-1 && x == n-1) return 1;

  // 메모이제이션
  int& ret = cache[y][x];
  if (ret != -1) return ret;

  int jumpSize = board[y][x];
  return jump2(y + jumpSize, x) || jump2(y, x + jumpSize); // 1 || 0 == 1, 1이 반환되면 도달가능
}
```

#### 동적 계획법 레시피

* 대개 동적 계획법 알고리즘은 아래 두 단계로 이루어짐

1. **주어진 문제를 완전 탐색을 이용해 해결**
2. **중복된 부분 문제를 한 번만 계산하도록 메모이제이션 적용**

* 재귀 호출을 이용하지 않고도 동적 계획법 알고리즘을 구현가능 == 반복적 동적 계획법

