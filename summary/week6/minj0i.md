# 8장 동적 계획법(dynamic programming)

## 8.1 도입
최적화 문제를 연구하는 수학 이론에서 유래한 이름

### 중복되는 부분 문제
큰 의미에서 분할 정복과 같은 접근 방식을 의미하며, 처음 주어진 문제를 더 작은 문제들로 나눈 뒤 각 조각의 답을 계산하고, 이 답들로부터 원래 문제에 대한 답을 계산해 내는 방식이다.
- 동적 계획법 vs 분할 정복: `문제를 나누는 방식`이 다름.
  - 동적 계획법: 어떤 문제는 두 개 이상의 문제를 푸는 데 사용될 수 있기 때문에, 이 문제의 답을 여러 번 계산하는 대신 한 번만 계산하고 계산 결과를 재활용하여 속도를 향상함. 그러기 위해 각 문제의 답을 저장해 두는 메모리의 장소를 캐시(cache)라고 부르며, 두번 이상 계산되는 부분 문제를 중복되는 부분 문제(overlapping subproblems)라고 부름.
- 동적 계획법 알고리즘의 가장 유명한 예: 이항 계수(binomial co-efficient), n개의 서로 다른 원소 중에서 r개의 원소를 순서없이 골라내는 방법의 수

```C++
// 재귀 호출을 이용한 이항 계수의 계산
int bino(int n, int r) {
  //기저사례: n=r(모든 원소를 다 고르는 경우) 혹은 r=0 (고를 원소가 없는 경우)
  if(r == 0 || n == r) return 1;
  return bino(n-1, r-1) + bino(n-1, r);
}
```

- 한 번 계산한 값을 저장해 뒀다 활용하는 최적화 기법: 메모이제이션(memoization)
  - 위의 bino보다 bino2는 훨씬 적게 반복함
```C++
// 메모이제이션을 이용한 이항 계수의 계산

// -1로 초기화해 둔다
int cache[30][30];
int bino2(int n, int r) {
  // 기저 사례
  if(r == 0 || n == r) return 1;
  // -1이 아니라면 한 번 계산했던 값이니 곧장 반환
  if(cache[n][r] != -1)
    return cache[n][r];
  // 직접 계산한 뒤 배열에 저장
  return cache[n][r] = bino2(n--1, r-1) + bino2(n-1, r);
}
```

### 메모제이션을 적용할 수 있는 경우
- 참조적 투명성(referential transparency): 함수의 반환 값이 그 입력 값만으로 결정되는 지 여부
- 창조적 투명함수(referential transparent function): 입력이 고정되어 있을 때 그 결과가 항상 같은 함수들   
메모제이션은 `참조적 투명 함수`의 경우에만 `적용할 수 있습니다`.(캐싱)

### 메모제이션 구현 패턴
```C++
// a와 b는 각각 [0, 2500) 구간 안의 정수
// 반환 값은 항상 int형 안에 들어가는 음이 아닌 정수
int someObscureFunction(int a, int b);
```
`someObscureFunction()`을 계산하는데 시간이 오래 걸리는 참조적 투명 함수라고 가정
```C++

```