# 8장 동적 계획법(dynamic programming)
[유튜브에서 찾은 강의](https://www.youtube.com/watch?v=-2Rta2Lnzmo)
## 8.1 도입
최적화 문제를 연구하는 수학 이론에서 유래한 이름

### 중복되는 부분 문제
큰 의미에서 분할 정복과 같은 접근 방식을 의미하며, 처음 주어진 문제를 더 작은 문제들로 나눈 뒤 각 조각의 답을 계산하고, 이 답들로부터 원래 문제에 대한 답을 계산해 내는 방식이다.
- 동적 계획법 vs 분할 정복: `문제를 나누는 방식`이 다름.
  - 동적 계획법: 어떤 문제는 두 개 이상의 문제를 푸는 데 사용될 수 있기 때문에, 이 문제의 답을 여러 번 계산하는 대신 한 번만 계산하고 계산 결과를 재활용하여 속도를 향상함. 그러기 위해 각 문제의 답을 저장해 두는 메모리의 장소를 캐시(cache)라고 부르며, 두번 이상 계산되는 부분 문제를 중복되는 부분 문제(overlapping subproblems)라고 부름.
- 동적 계획법 알고리즘의 가장 유명한 예: 이항 계수(binomial co-efficient), n개의 서로 다른 원소 중에서 r개의 원소를 순서없이 골라내는 방법의 수

```C++
// 재귀 호출을 이용한 이항 계수의 계산
int bino(int n, int r) {
  //기저사례: n=r(모든 원소를 다 고르는 경우) 혹은 r=0 (고를 원소가 없는 경우)
  if(r == 0 || n == r) return 1;
  return bino(n-1, r-1) + bino(n-1, r);
}
```

- 한 번 계산한 값을 저장해 뒀다 활용하는 최적화 기법: 메모이제이션(memoization)
  - 위의 bino보다 bino2는 훨씬 적게 반복함
```C++
// 메모이제이션을 이용한 이항 계수의 계산

// -1로 초기화해 둔다
int cache[30][30];
int bino2(int n, int r) {
  // 기저 사례
  if(r == 0 || n == r) return 1;
  // -1이 아니라면 한 번 계산했던 값이니 곧장 반환
  if(cache[n][r] != -1)
    return cache[n][r];
  // 직접 계산한 뒤 배열에 저장
  return cache[n][r] = bino2(n--1, r-1) + bino2(n-1, r);
}
```

### 메모제이션을 적용할 수 있는 경우
- 참조적 투명성(referential transparency): 함수의 반환 값이 그 입력 값만으로 결정되는 지 여부
- 창조적 투명함수(referential transparent function): 입력이 고정되어 있을 때 그 결과가 항상 같은 함수들   
메모제이션은 `참조적 투명 함수`의 경우에만 `적용할 수 있습니다`.(캐싱)

### 메모제이션 구현 패턴
```C++
// a와 b는 각각 [0, 2500) 구간 안의 정수
// 반환 값은 항상 int형 안에 들어가는 음이 아닌 정수
int someObscureFunction(int a, int b);
```
`someObscureFunction()`을 계산하는데 시간이 오래 걸리는 참조적 투명 함수라고 가정
```C++
// 메모제이션의 사용 예

// 전부 -1로 초기화해둔다
int cache[2500][2500];
// a와 b는 각각 [0, 2500) 구간 안의 정수
// 반환 값은 항상 int형 안에 들어가는 음이 아닌 정수
int someObscureFunction(int a, int b) {
  // 기저 사례를 처음에 처리한다
  if(...) return ...;
  // (a, b)에 대한 답을 구한 적이 있으면 곧장 반환
  int& ret = cache[a][b];
  if(ret != -1) return ret;
  // 여기에서 답을 계산한다.
  ...
  return ret;
}
int main() {
  //memset()을 이용해 cache 배열을 초기화한다.
  memset(cache, -1, sizeof(cache));
}
```
1. 기저사례를 항상 제일 먼저 처리: 입력이 범위를 벗어난 경우 등을 기저사례로 처리하면 매우 유용함
2. 함수의 반환 값이 항상 0 이상이라는 점을 이용해 cache[]를 모두 -1로 초기화
3. ret가 cache[a][b]에 대한 참조형(reference)!. ret값을 바꾸면 cache[a][b]도 바뀌기 때문에 답을 저장할때도 귀찮게 cache[a][b]라고 안써도 됨. 다차원 배열일때 유용한 방법
4. memset()을 이용해 초기화하는 부분. 다중 for문보다 간편함

### 메모이제이션의 시간 복잡도 분석
`(존재하는 부분 문제의 수)X(한 부분 문제를 풀 때 필요한 반복문의 수행 횟수)`   
r의 최대치는 n이니 bino2(n, r)을 계산할 때 문제의 수 최대값은 O(n<sup>2</sup>)   
각 부분 문제를 계산할 때 걸리는 시간은 반복문이 없으니 O(1)임으로
O(n<sup>2</sup>)O(1) = O(n<sup>2</sup>)   
하지만 수행 시간의 상한 값일 뿐, 실제 수행 시간은 이 식보다 훨씬 작을 수 있다.

### 예제: 외발 뛰기 (문제 ID: JUMPGAME, 난이도 하)
#### 재귀 호출에서 시작하기
jump(y,x) = (y,x)에서부터 맨 마지막 칸까지 도달할 수 있는지 여부를 반환한다.   
게임판의 (y,x) 위치에 있는 수를 jumpSize라고 하면,   
아래쪽으로 뛸 경우: jump(y+jumpSize, x)   
오른쪽으로 뛸 경우: jump(y, x+jumpSize)로 표현
`jump(y,x) = jump(y+jumpSize, x) || jump(y,x+jumpSize)

```C++
// 외발 뛰기 문제를 해결하는 재귀 호출 알고리즘
int n, board[100][100];
bool jump(int y, int x) {
  // 기저 사례: 게임판 밖을 벗어나나 경우
  if(y >= n || x >= n) return false;
  // 기저 사례: 마지막 칸에 도착한 경우
  if (y == n-1 && x == n -1) return true;
  int jumpSize = board[y][x];
  return jump(y + jumpSize, x) || jump(y, x + jumpSize);
}
```

#### 메모제이션 적용하기
완전 탐색이 만드는 경로의 수는 엄청나게 많지만, jump()에 주어지는 입력의 개수는 100*100 = 10,000개 뿐이라는 것.   
비둘기집의 원리(비둘기집 원리는 n+1개의 물건을 n개의 상자에 넣을 때 적어도 어느 한 상자에는 두 개 이상의 물건이 들어 있다는 원리를 말한다.)에 의해 중복으로 해결되는 부분 문제들이 항상 존재함을 알 수 있음.   

```C++
// 외발 뛰기 문제를 해결하는 동적 계획법 알고리즘
int n, board[100][100];
int cache[100][100];
int jump2(int y, int x) {
  // 기저 사례 처리
  if (y >= n || x >= n) return 0;
  if (y == n-1 && x == n-1) return 1;
  // 메모이제이션
  int& ret = cache[y][x];
  if (ret != -1) return ret;
  int jumpSize = board[y][x];
  return ret = (jump2(y + jumpSize, x) || jump2(y, x + jumpSize));
}
```
- 위의 코드에서 boolean 값을 반환했으나, jump2()는 정수를 반환함
- jump2()가 반환하는 값은 참/거짓 둘 중의 하나 이나, boolean값으로는 true 아니면 false만 반환할 수 있고 계산되지 않은 상태인지 아닌지 알 수 있는 방법이 없음
- 1 또는 0의 정수를 반환하기로 약속하면 -1로 초기화한 정수형 배열을 캐시로 사용할 수 있음.
- 이 문제는 그래프로 모델링해보면 아주 간단한 도달 가능성 문제가 됨(7부)

### 동적 계획법 레시피
동적 계획법 알고리즘의 구현
1. 주어진 문제를 완전 탐색을 이용해 해결
2. 중복된 문제를 한 번만 계산하도록 메모이제이션을 적용

### 다른 구현 방법
재귀 호출을 이용하지 않고 동적 계획법 알고리즘을 구현 가능 = 반복적 동적 계획법(9.21절 참고)

(8.2 와일드카드-난이도 중, 8.3 풀이:와일드카드 패스)

## 8.4 전통적 최적화 문제들
동적 계획법의 가장 일반적인 사용처는 최적화 문제(여러 개의 가능한 답 중 가장 좋은 답을 찾아내는 문제)의 해결.  
메모이제이션을 적용하여 완전 탐색보다 더 효율적으로 문제를 풀 수 있는 경우가 존재함.   

### 예제: 삼각형 위의 최대 경로 (문제 ID: TRIANGLEPATH, 난이도 하)
![예제](https://blog.kakaocdn.net/dn/bVdS4g/btqGDQW4kxA/litNzt84rox0IDiTQtmvu0/img.jpg)
#### 완전 탐색으로 시작하기
경로를 가로줄로 조각 낸 뒤, 각 조각에서 아래로 내려갈 지 오른쪽으로 내려갈지를 선택하면서 모든 경로를 만듬.   
재귀함수를 이용해 현재 위치와 지금까지 만난 숫자들의 합을 구함

```
pathSum(y, x, sum) = 현재 위치가 (y, x)이고, 지금까지 만난 수의 합이 sum일 때, 이 경로를 맨 아래줄까지 연장해서 얻을 수 있는 최대 합을 반환
```

#### 무식하게 메모이제이션 적용하기
이 문제에서 가능한 경로의 개수는 삼각형의 가로줄이 하나 늘어날 때마다 두 배씩 늘어나기 때문에 가능한 경로의 수는 2<sup>n-1</sup>이 된다.   
n<=20인 정도는 가능하지만 늘어나면 계산하기 힘듬.

```C++
// 삼각형 위의 최대 경로 문제를 푸는 메모이제이션 코드

// MAX_NUMBER: 한 칸에 들어갈 숫자의 최대치
int n, triangle[100][100];
int cache[100][100][MAX_NUMBER*100 + 1];
// (y,x)위치까지 내려오기 전에 만난 숫자들의 합이 sum일 때
// 맨 아래줄까지 내려가면서 얻을 수 있는 최대 경로를 반환
int path1(int y, int x, int sum) {
  // 기저 사례: 맨 아래 줄까지 도달했을 경우
  if(y == n-1) return sum + triangle[y][x];
  // 메모이제이션
  int& ret = cache[y][x][sum];
  if(ret != -1) return ret;
  sum += triangle[y][x];
  return ret = max(path1(y+1, x+1, sum), path1(y+1, x, sum));
}
```
- 226쪽 그림 8.6의 (b)와 같이 2<sup>i</sup>꼴의 숫자로만 구성된 삼각형이 있닥도 하면 서로 다른 경로는 합도 항상 다르기 때문에 완전 탐색과 다를 바가 없음

