# **6 무식하게 풀기**

## **6.1 도입**
* '무식하게 푼다(brute-force)'  = 컴퓨터의 빠른 계산 능력을 이용해 가능한 경우의 수를 일일이 나열하면서 답을 찾는 방법 = '완전 탐색 (exhaustive search)'
* 충분히 빠르면서도 가장 구현하기 쉬운 대안이 됨

## **6.2 재귀 호출과 완전 탐색**
* 재귀호출(recursive function): 
    * 문제를 푸는 각 조각들의 형태가 유사해지는 작업 (예: for문)일 때 유용한 개념
    * 자신이 수행할 작업을 유사한 형태의 여러 조객으로 쪼갠 뒤 그 중 한 조각을 수행하고, 나머지를 자기 시잔을 호출해 실행하는 함수
    * 재귀호출은 완전 탐색을 구현할 때 아주 유용 

```C++
// 필수 조건: n >= 1
// 결과: 1 부터 n까지의 합을 반환한다.
int recursiveSum(int n) {
    if(n == 1) return 1; //더 이상 쪼개지지 않을 때 -> '기저사례'
    return n + recursiveSum(n-1);
}
```
## **기저사례**
* '더 이상 쪼개지지 않는' 최소한의 작업에 도달했을 때 답을 반환하는 조건문
* 기저 사례를 선택 시, 존재하는 모든 입력이 항상 기저 사례의 답을 이용해 계산될 수 있도록 신경써야 함

## **시간 복잡도 분석**

* 완전 탐색은 가능한 답 후보들을 모두 만들어 보기 때문에 시간 복잡도를 계산하기 위해서는 가능한 후보의 수를 전부 세어 보기만 하면 됨
* 후보의 수를 계산하는건 매우 단순 하지만 답을 하나라도 찾으면 바로 종료 하기 때문에 분석이 까다로움
* 최악의 경우는 답이 존재하지 않는 경우가 많음. 존재하지 않다면 모든 경우를 다 해봐야함.
* 알고리즘 시간복잡도가 증가하여 완전탐색으로 해결하기 어려운 경우 동적 계획법을 통해 해결 할 수 있음.

## **완전 탐색 레시피**
1. 완전 탐색은 존재하는 모든 답을 하나씩 검사하므로, 걸리는 시간은 가능한 답의 수에 정확히 비례함. 최대 크기의 이력을 가정했을 때 답의 개수를 계산하고 이들을 모두 제한 시간 안에 생성할 수 있을지를 가늠함. 만약 시간 안에 계싼할 수 없다면 3부의 설계 패러다임을 적용해야 함. 
2. 가능한 모든 답의 후보를 만드는 과정을 여러 개의 선택으로 나눕니다. 각 선택은 답의 후보를 만드는 과정의 한 조각이 됨.
3. 그 중 하나의 조각을 선택해 답의 일부를 만들고, 나머지 답을 재귀 호출을 통해 완성.
4. 조각이 하나밖에 남지 않은 경우, 혹은 하나도 남지 않은 경우에는 답을 생성했으므로 이것을 기저 사례로 선택해 처리.

## **이론적 배경: 재귀 호출과 부분 문제** 
* 재귀 호출을 논의할 때 '문제'란 항상 수행해야 할 작업과 그 작업을 적용할 자료의 조합을 의미함
* **보글게임**
    1. 현재 위치(y, x)에 단어의 첫 글자가 있는가?
    2. 윗 칸 (y-1, x)에서 시작해서, 단어의 나머지 글자들을 찾을 수 있는가?
    3. 왼쪽 윗 칸(y-1, x-1)에서 시작해서 단어의 나머지 글자들을 찾을 수 있는가?
        ..
* 문제를 구성하는 조각들 중 하나를 뺐기 때문에, 이 문제들은 원래 문제의 일부라고 말할 수 있음.
* 이런 문제들을 원래 문제의 부분 문제라고 함.

## **문제: 소풍**
* 문제 정의: 학생을 2명씩 짝을 지어주기
* 단, 항상 서로 친구인 친구들 먼저 짝을 지어주고, 나머지 친구가 아닌 학생들끼리도 짝을 지어줘야 함
* 시간 및 메모리 제한: 1초 내에 실행되어ㅑ 하고, 64MB 이하의 메모리만 사용해야 함
* 방법
1. 완전 탐색
    * 답을 만드는 과정을 여러개 조각으로 나눠야 하는데, 여기에서는 (N/2)개의 조각으로 나워서 한 조각마다 두 학생을 짝지어줌
    
2. 중복으로 세는 문제
* 잘못된 코드
    * 같은 학생 쌍을 두번 짝지어주고 있음 (0,1)과 (1,0)을 따로 세고 있음
    * 다른 순서로 학생들을 짝지어주는 것을 서로 다른 경우로 세고 있음. 
* 해결 방안: 답 중에서 사전 순으로 가장 먼저 오는 답 하나만을 셈

```C++
int n;
bool areFriends [10][10];
int countPairings(bool taken[10]) {
    //기저사례: 모든 학생이 짝을 찾았으면 한 가지 방법을 찾았으니 종료한다. 
    bool finished = true;
    for(int i = 0; i < n; ++i) {
        if(!taken[i]){
            finished = false;
        }
    }
    if(finished) {
        return 1;
    }
    int ret = 0;
    //서로 친구인 두 학생을 찾아 짝을 지어준다.
    for(int i = 0; i < n ; ++i) {
        for(int j = 0; j < n; ++j) {
            if(!taken[i] && !taken[j] && areFriends[i][j]) {
                taken[i] = taken[j] = true;
                ret += countPairings(taken);
                taken[i] = taken[j] = false;
            }
        }
    }
    return ret;
}
```

* 수정된 코드
```C++
int n;
bool areFriends [10][10];
int countPairings(bool taken[10]) {
    int firstFree = -1;
    for(itn i = 0; i < n; ++i) {
        if(!taken[i]) {
            firstFree = i;
            break;
        }
    }

    if(firstFree == -1) return 1;
    int ret = 0;
    //이 학생과 짝지을 학생을 결정
    for(int pairwith = firstfree + 1; pairwith < n; ++pairwith) {
        if(!taken[pairwith] && areFriends[firstfree][pairwith]) {   
            taken[firstfree] = taken[pairwith] = true;
            ret += countPairings(taken);
            taken[firstfree] = taken[pairwith] = false;
        }
    }
    return ret;
}
```
3. 답의 수의 상한
* 모든 답을 생성해 가며 답의 수를 세는 재귀 호출 알고리즘
* 답의 수에 정비례하는 시간이 걸림

## **문제: 게임판 덮기**







