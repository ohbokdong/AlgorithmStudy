## 알고리즘 문제해결 전략 27 - 그래프의 표현과 정의

---

### 그래프의 정의


* 그래프 G(V, E) 는 어떤 자료나 개념을 표현하는 정점(Vertex)들의 집합 V와 이들을 연결하는 간선(Edge)들의 집합 E로 구성된 자료 구조
* 그래프는 정점들과 간선들로 정의하며, 정점의 위치 정보나 간선의 순서 등은 그래프의 정의에 포함되지 않음

![graph_example](https://media.geeksforgeeks.org/wp-content/cdn-uploads/undirectedgraph.png)

### 그래프의 종류

* 그래프는 표현하고자 하는 대상에 따라 여러 가지 변형된 형태를 가질 수 있음
* 정점이나 간선에 추가적인 속성을 부여할 수도 있고, 존재할 수 있는 간선이나 정점의 형태에 제약을 두기도 함
* **유향 또는 방향 그래프(Directed Graph)**
  * 방향 그래프는 각 간선이 방향이라는 새로운 속성을 가짐
  * 방향 그래프에선 두 정점 u, v가 있을 때 u에서 v로가는 간선과 v에서 u로 가는 간선이 서로 다른 간선임
  * 짝사랑 관계, 도로망에서 일방 통행 등이 방향 그래프로 표현할 수 있는 좋은 예
* **무향 그래프(Undirected Graph)**
  * 간선에 방향이 없는 그래프
* **가중치 그래프(Weighted Graph)**
  * 가중치 그래프는 각 간선에 가중치(Weight)라 불리는 실수 속성이 부여함
  * 두 도시 사이의 거리, 두 물건 사이의 교환 비율, 두 사람 사이의 호감도 등의 다양한 정보를 표현하는 데 사용 가능
  * 최소 스패닝 트리 문제나 최단 경로 문제 등이 가중치 그래프를 다루는 중요한 문제들
* **다중 그래프(Multi Graph)**
  * 두 정점 사이에 두 개 이상의 간선이 있을 수 있는 그래프
  * 도로망의 경우 같은 두 지점을 잇는 두 개 이상의 도로가 있을 수 있어 다중 그래프로 표현 가능
  * 반대로 두 정점 사이에 최대 한 개의 간선만 있는 그래프를 **단순 그래프(Simple Graph)**라고 부름
* **트리 혹은 루트 없는 트리(Unrooted Tree)**
  * 부모 자식 관계가 없을 뿐, 간선들의 연결 관계만 보면 트리와 같은 무향 그래프를 말함
  * 간선들의 연결 관계가 트리와 같다는 말은, 간선을 통해 두 정점을 잇는 방법이 딱 하나밖에 없다는 의미
* **이분 그래프(Bipartite Graph)**
  * 그래프의 정점들을 겹치지 않게 두 개의 그룹으로 나눠서 서로 다른 그룹에 속한 정점들 간에만 간선이 존재하도록 만들 수 있는 그래프
  * 여러명의 이성애자들을 그래프로 표현하되, 두사람이 서로에게 관심이 있을 경우 두 정점 사이에 간선이 있도록 하고 이 그래프를 남성과 여성으로 나누면 간선은 항상 두 그룹 사이에만 있음(동성애자가 포함돼 있지 않다는 조건하)
* 한 그래프가 두 가지 이상의 속성을 함께 가지는 경우도 존재, 방향 가중치 그래프, 이분 가중치 그래프 등이 이에 해당됨
  * 그 중 이름을 붙여서 따로 부르는 중요한 그래프는 DAG
* **사이클 없는 그래프(Directed Acyclic Graph, DAG)**
  * 방향 그래프인데 한 점에서 출발해 자기 자신으로 돌아오는 경로(사이클)가 존재하지 않는 그래프
  * 간선의 방향을 무시할 경우 DAG에는 사이클이 존재할 수도 있음

![graphs](https://beenpow.github.io/img/2020-01-01-Jongman-ch27-1-1.png)



### 그래프의 경로(Path) 

* **경로(Path)란 끝과 끝이 서로 연결된 간선들을 순서대로 나열한 것**
* 경로 중 한 정점을 최대 한 번만 지나는 경로를 단순 경로(Simple Path)라고 함
  * 현대 그래프 이론에서 경로라고 하면 대부분은 단순 경로를 의미함
* 시작한 점에서 끝나는 경로를 사이클(Cycle) 혹은 회로라고 부름

### 그래프의 사용 예

* 철도망의 안정성 분석
  * 절단점 찾기 알고리즘
* 소셜 네트워크 분석
  * 너비 우선 탐색
* 인터넷 전송 속도 계산
  * 최소 스패닝 트리 알고리즘
* 한 붓 그리기
  * 주어진 그래프의 모든 간선을 한 번씩만 지나는 경로를 찾는 문제, 오일러 경로(Eulerian Path)
* 외환 거래
  * 아비트러지(Arbitrage)가 가능한 사이클을 찾기


### 암시적 그래프 구조들
* 현실 세계에서 그래프 같은 형태를 갖는 구조가 아니라도 그래프를 통해서 표현하면 쉽게 해결할 수 있는 문제들이 종종 있음
  * **이와 같은 그래프 구조를 암시적 그래프(Implicit Graph)라고 함**
* **암시적 그래프 구조의 예**
  * 할일 목록 정리
      * 서로 의존 관계에 있는 여러 할 일이 있을 때 이들을 한 번에 하나씩 해 나갈 방법이 있는지, 있다면 어느 순서대로 하면 되는지 계산하는 문제(위상 정렬, Topological Sorting)
  * 15-퍼즐
      * 15퍼즐을 푸는 문제를 그래프 상에 두 점 사이를 잇는 가장 짧은 경로를 구하는 최단 경로 문제로 변경해 풀 수 있음
  * 게임판 덮기
      * 매칭 알고리즘
  * 회의실 배정
      * 만족성 문제(Satisfiability Problem)
      * 모든 사람이 두 선택지 중 하나를 선택해야 하는 문제(2-SAT)

### 그래프의 표현 방법
* 그래프는 트리에 비해 훨씬 정적인 용도로 사용됨
* 정적이라는 말은 새로운 정점이나 간선을 추가하고 삭제하는 일이 자주 발생하지 않는다는 의미
* 따라서 대부분의 그래프는 구조 변경이 어렵더라도 좀 더 간단하고 메모리를 적게 차지하는 방법으로 구현
    * 좀 더 간단한 방법이란 그래프의 정점들을 객체의 인스턴스로 표현하는 대신 각 정점에 0부터 시작하는 번호를 붙이고, 배열에 각 정점의 정보를 저장하는 것
    * 각 간선은 반대쪽 끝 정점 객체의 포인터 대신 반대쪽 정점의 번호를 저장하는 식으로 구현됨
* 그래프의 표현 방식은 간선의 정보를 어떤 식으로 저장하느냐에 따라 크게 두 가지로 나뉨
  * **인접 리스트(Adjacency List) 표현 방식**
  * **인접 행렬(Adjacency Matrix) 표현 방식**

### 인접 리스트(Adjacency List) 표현 방식

* **그래프의 각 정점마다 해당 정점에서 나가는 간선의 목록을 저장해서 그래프로 표현하는 방법**
  * 그래프는 각 정점마다 하나의 연결리스트를 가짐

```c++
vector<list<int>> adjacent;
```

* adjacent\[i\]는  정점 i와 간선을 통해 연결된 정점들의 번호를 저장하는 연결 리스트
* 만약 가중치 그래프 등 간선이 추가적 속성을 갖는 그래프를 표현해야 한다면 간선의 정보를 구조체로 표현하면 됨
    * 실제 대회코드에서는 좀 더 단순하게 `pari<int, int>`를 사용하는 경우도 많음

```c++
struct Edge {
    int vertax; // 간선의 반대쪽 끝 점의 번호
    int weight; // 간선의 가중치
}
```

* 단점은 두 정점이 주어질 때 정점이 연결돼 있는지 알기 위해선 연결 리스트를 일일이 뒤져야 함



### 인접 행렬(Adjacency Matrix) 표현 방식

* **|V| * |V| 크기의 행렬, 즉 2차원 배열을 이용해 그래프의 간선 정보를 저장, 가장 간단한 형태의 인접 행렬 표현은 단순히 2차원 불린 값 배열이 됨**
  * 인접 리스트 표현 방식일 때 두 정점의 연결 여부를 판단하는 단점의 연산 속도를 높이기 위해 고안된 그래프 표현 방식이 인접 행렬 표현 방식

```c++
vector<vector<bool>> adjacent;
```

* adjacent[i, j]는 정점 i에서 정점 j로 가는 간선이 있는지를 나타내는 불린 값 변수
    * 가중치 그래프를 인접 행렬로 표현하려면 각 간선의 정보를 불린이 아니라 정수나 실수로 두면 됨
    * 두 정점 사이에 간선이 없는 경우 -1 또는 아주 큰 값 등 존재할 수 없는 값으로 지정하면 됨

### 인접 행렬 표현과 인접 리스트 표현의 비교
* 인접 행렬, 인접 리스트 표현 방식은 정반대의 특성을 가져서 한 방식의 단점이 바로 다른 방식의 장점, 구현하려는 알고리즘의 종류나 그래프의 종류에 따라 적절히 선택, 사용해야 함
* 인접 행렬 표현의 가장 큰 장점은 정점의 번호 u, v가 주어졌을 때 두 정점을 잇는 간선이 있는지를 한 번의 배열 접근만으로 확인할 수 있다는 것
    * 인접 리스트의 경우 간선 (u, v)가 존재하는지 확인하기 위해서는 연결 리스트 adjacent\[u\]를 처음부터 읽어가면서 각 원소를 일일이 확인해야 함
* 인접 행렬 표현은 |V| * V| 크기의 2차원 배열을 사용하기 때문에 실제 간선의 개수와 관계없이 항상 O(|V|<sup>2</sup>) 크기의 공간을 사용한다는 문제점이 있음
    * 인접 리스트 표현은 |V| 개의 연결 리스트에 실제 간선 수 만큼의 원소가 들어 있으므로 O(|V| + |E|)의 공간만을 사용
    * 간선 수가 |V|<sup>2</sup>와 비슷하다면 두 표현 방식은 비슷한 양의 메모리를 사용하지만, |V|<sup>2</sup>의 비해 간선의 수가 훨씬 적은 그래프가 현실 세계에 숱하게 등장하므로 결과적으로 큰 차이를 냄
* 간선의 수가 |V|<sup>2</sup>에 비해 훨씬 적은 그래프를 희소 그래프(Sparse Graph)라 함
    * 반대로 간선의 수가 거의 |V|<sup>2</sup>에  비례하는 그래프를 밀집 그래프(Dense Graph)라 함
    * 희소 그래프에 대해서는 인접 리스트를, 밀집 그래프에 대해서는 인접 행렬을 사용하는 것이 더 유리함
* 그래프를 어떤 방식으로 표현하느냐에 따라 알고리즘의 시간 복잡도를 바꿀 수 있음

### 암시적 그래프 표현
* 그래프를 이용해 푸는 문제라도 그래프를 항상 직접 메모리에 표현해야 하는 것은 아님
* 입력이 직접적으로 그래프 형태를 띠지 않는 문제의 경우, 그래프 구조를 직접 사용하지 않고도 문제를 해결할 수 있는 경우가 자주 있음
    * 문제가 비교적 단순한 경우, 일일이 입력을 그래프로 표현하기는 번거로운 경우
        * 미로에서 최단 경로 찾기
    * 그래프의 크기가 아주 큰데 실제로는 그 중 일부만 사용하는 경우
        * 15퍼즐
* 암시적 그래프 표현이 항상 더 좋은 것은 아님, 암시적 그래프 표현을 사용하면 그래프를 사용하는 알고리즘과 변환 과정이 합쳐져 코드가 더 복잡해짐
    * 그래프에 대해 복잡한 연산이나 알고리즘을 수행할 거라면 번거롭더라도 입력을 미리 그래프 표현으로 바꿔 두는 것이 전체 코드를 간결하게 할 수 있음
