# **분할 정복**

## **7.1 도입**

주어진 문제를 둘 이상의 부분문제로 나눈 뒤 각 문제에 대한 답을 재귀 호출을 이용해 계산하고 각 부분 문제의 답으로 부터 전체 문제의 답을 계산

**재귀 호출과 다른점**

문제를 한 조각과 나머지 전체로 나누지 않고 같은 크기의 부분문제로 나눔 

분할 정복을 사용하는 알고리즘들은 세가지의 구성요소를 갖고 있음.
- 분제를 더 작은 무제로 분할하는 과정 (divide)
- 각 문제에 대해 구한 답을 원래 문제에 대한 답으로 병합하는 과정 (merge)
- 더이상 답을 분할하지 않고 곧장 풀 수 있는 매우 작은 문제 (base case)

문제 해결하기 위해서는 문제에 몇 가지 특성이 성립해야함.

1. 둘 이상의 부분 문제로 나누는 자연스러운 방법
2. 부분 문제의 답을 조합해 문제의 답을 계산하는 효율적인 방법이 있어야함


## **행렬의 거듭제곱 (p.178)**

### 나누어 떨어지지 않을 때의 분할과 시간 복잡도

대부분의 분할 정복 알고리즘은 가능한 한 절받에 가깝게 문제를 나누고자 함

같은 문제라도 어떻게 분할 하느냐에 따라 시간 복잡도 차이가 커진다는것을 보여주는 좋은 예

![행렬 거듭제곱을 위한 두 가지 분할 방식의 비교 그림](https://github.com/ohbokdong/AlgorithmStudy/blob/main/summary/week5/images/DC_1.jpg)



## **7.2문제: 쿼드 트리 뒤집기 (p.189)**

대량의 좌표 데이터를 메모리 안에 압축해 저장하기 위해 사용하는 여러 기법 중 쿼드 트리 라는 것이 있음

쿼트 트리는 2n승* 2n승 크기의 흑백 그림을 가음과 같은 과정을 거쳐 문자열로 압축

- 모든 픽셀이 검은색 = b
- 모든 픽셀이 읜색 = w
- 모든 픽셀이 같은 색이 아니면 = x
 
### **압축 다 풀지 알고 뒤집기 (p.193)**

예시)  2의20승 * 2의20승 크기의 그림
쿼드 트리는 이런 그림(흑백)을 아주 짧게 압축 할수 있지만 압축을 해제하는 결과는 1테라바이트나 되기 때문에 도저히 우리가 다룰 수 없음

이런 경우 쓸수 있는 방법은 압축을 해제한 결과를 메모리에 다 저장하는 대신 결과 이미지를 뒤집은 결과를 곧장 생성하는 코드를 작성

코드 7.6(p.194) 보면 코드7.5(p.193)처럼 배열이 존재하지 않음(압축해제 x)

## **7.4문제: 울타리 잘라내기 (p.195)**

N개의 나무 판자를 붙여 세운 울타리가 있음 -> 가장 크게 잘라내기임


### **분할 정복 알고리즘의 설계 (p.197)**

분할 정복 알고리즘을 설계하기 위해서는 문제를 어떻게 분할할지를 가장 먼저 결정해야함

1. 가장 큰 직사각형을 왼쪽 부분 문제에서만 잘라 낼수 있음.
2. 가장 큰 직사각형을 오른쪽 부분 문제에서만 잘라 낼수 있음.
3. 가장 큰 직사각형은 왼쪽 부분 문제와 오른쪽 부분 문제에 걸쳐 있음.

### **정당성 증명 (p.199)**

핵심은 걸쳐있는 직사각형을 찾을 때 각 단계마다 더 높은 판자를 택하는 것이 항상 옳음을 보이는 부분

귀류법을 이용해 쉽게 증명 가능

R = 우리가 찾은 최대 직사각형보다 크다고 가정

R' = 우리가 고려한 사각형중 R과 너비가 같은 사각형

R과 R'는 둘다 부분 문제 경계에 있는 두개의 판자를 포함하므로 항상 겹치는 부분이 있음.

두 개의 판자에서 시작해 R'을 찾아냈다면 중간에 반드시 언젠가 판자 A와 B의 높이를 빅교 해야만 함.

이때 우리가 판자 B를 선택했다면 판자 B가 A보다 낮을 리 없다는 뜻

R은 B보다 높을 수 없고 가정의 모순임으로 R'보다 넓은 R은 존재하지 않음. 고려하는 사각형중에 반드시 최대 사각형이 있다는 사실을 알수 있음.
















